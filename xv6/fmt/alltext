0100 typedef unsigned int   uint;
0101 typedef unsigned short ushort;
0102 typedef unsigned char  uchar;
0103 typedef uint pde_t;
0104 
0105 
0106 
0107 
0108 
0109 
0110 
0111 
0112 
0113 
0114 
0115 
0116 
0117 
0118 
0119 
0120 
0121 
0122 
0123 
0124 
0125 
0126 
0127 
0128 
0129 
0130 
0131 
0132 
0133 
0134 
0135 
0136 
0137 
0138 
0139 
0140 
0141 
0142 
0143 
0144 
0145 
0146 
0147 
0148 
0149 
0150 #define NPROC        64  
0151 #define KSTACKSIZE 4096  
0152 #define NCPU          4  
0153 #define NOFILE       16  
0154 #define NFILE       100  
0155 #define NINODE       50  
0156 #define NDEV         10  
0157 #define ROOTDEV       1  
0158 #define MAXARG       32  
0159 #define MAXOPBLOCKS  10  
0160 #define LOGSIZE      (MAXOPBLOCKS*3)  
0161 #define NBUF         (MAXOPBLOCKS*3)  
0162 #define FSSIZE       1000  
0163 
0164 
0165 
0166 
0167 
0168 
0169 
0170 
0171 
0172 
0173 
0174 
0175 
0176 
0177 
0178 
0179 
0180 
0181 
0182 
0183 
0184 
0185 
0186 
0187 
0188 
0189 
0190 
0191 
0192 
0193 
0194 
0195 
0196 
0197 
0198 
0199 
0200 
0201 
0202 #define EXTMEM  0x100000            
0203 #define PHYSTOP 0x20000000         
0204 #define DEVSPACE 0xFE000000         
0205 #define BOOTPARAM 0x50000
0206 
0207 
0208 #define KERNBASE 0x80000000         
0209 
0210 #define KERNLINK (KERNBASE+EXTMEM)  
0211 
0212 #define PCI_BAR_BASE 0x80000000
0213 #define PCI_VP_OFFSET 0x40000000
0214 #define PCI_P2V(a) (((uint)(a)) + PCI_VP_OFFSET)
0215 #define V2P(a) (((uint) (a)) - KERNBASE)
0216 #define P2V(a) (((void *) (a)) + KERNBASE)
0217 
0218 #define V2P_WO(x) ((x) - KERNBASE)    
0219 #define P2V_WO(x) ((x) + KERNBASE)    
0220 
0221 
0222 
0223 
0224 
0225 
0226 
0227 
0228 
0229 
0230 
0231 
0232 
0233 
0234 
0235 
0236 
0237 
0238 
0239 
0240 
0241 
0242 
0243 
0244 
0245 
0246 
0247 
0248 
0249 
0250 struct buf;
0251 struct context;
0252 struct file;
0253 struct inode;
0254 struct pipe;
0255 struct proc;
0256 struct rtcdate;
0257 struct spinlock;
0258 struct sleeplock;
0259 struct stat;
0260 struct superblock;
0261 
0262 
0263 void            binit(void);
0264 struct buf*     bread(uint, uint);
0265 void            brelse(struct buf*);
0266 void            bwrite(struct buf*);
0267 
0268 
0269 void            consoleinit(void);
0270 void            cprintf(char*, ...);
0271 void            consoleintr(int(*)(void));
0272 void            panic(char*) __attribute__((noreturn));
0273 
0274 
0275 int             exec(char*, char**);
0276 
0277 
0278 struct file*    filealloc(void);
0279 void            fileclose(struct file*);
0280 struct file*    filedup(struct file*);
0281 void            fileinit(void);
0282 int             fileread(struct file*, char*, int n);
0283 int             filestat(struct file*, struct stat*);
0284 int             filewrite(struct file*, char*, int n);
0285 
0286 
0287 void            readsb(int dev, struct superblock *sb);
0288 int             dirlink(struct inode*, char*, uint);
0289 struct inode*   dirlookup(struct inode*, char*, uint*);
0290 struct inode*   ialloc(uint, short);
0291 struct inode*   idup(struct inode*);
0292 void            iinit(int dev);
0293 void            ilock(struct inode*);
0294 void            iput(struct inode*);
0295 void            iunlock(struct inode*);
0296 void            iunlockput(struct inode*);
0297 void            iupdate(struct inode*);
0298 int             namecmp(const char*, const char*);
0299 struct inode*   namei(char*);
0300 struct inode*   nameiparent(char*, char*);
0301 int             readi(struct inode*, char*, uint, uint);
0302 void            stati(struct inode*, struct stat*);
0303 int             writei(struct inode*, char*, uint, uint);
0304 
0305 
0306 void            ideinit(void);
0307 void            ideintr(void);
0308 void            iderw(struct buf*);
0309 
0310 
0311 void            ioapicenable(int irq, int cpu);
0312 extern uchar    ioapicid;
0313 void            ioapicinit(void);
0314 
0315 
0316 char*           kalloc(void);
0317 void            kfree(char*);
0318 void            kinit1(void*, void*);
0319 void            kinit2(void*, void*);
0320 
0321 
0322 void            kbdintr(void);
0323 
0324 
0325 void            cmostime(struct rtcdate *r);
0326 int             lapicid(void);
0327 extern volatile uint*    lapic;
0328 void            lapiceoi(void);
0329 void            lapicinit(void);
0330 void            lapicstartap(uchar, uint);
0331 void            microdelay(int);
0332 
0333 
0334 void            initlog(int dev);
0335 void            log_write(struct buf*);
0336 void            begin_op();
0337 void            end_op();
0338 
0339 
0340 extern int      ismp;
0341 void            mpinit(void);
0342 
0343 
0344 void            picenable(int);
0345 void            picinit(void);
0346 
0347 
0348 
0349 
0350 
0351 int             pipealloc(struct file**, struct file**);
0352 void            pipeclose(struct pipe*, int);
0353 int             piperead(struct pipe*, char*, int);
0354 int             pipewrite(struct pipe*, char*, int);
0355 
0356 
0357 
0358 int             cpuid(void);
0359 void            exit(void);
0360 int             fork(void);
0361 int             growproc(int);
0362 int             kill(int);
0363 struct cpu*     mycpu(void);
0364 struct proc*    myproc();
0365 void            pinit(void);
0366 void            procdump(void);
0367 void            scheduler(void) __attribute__((noreturn));
0368 void            sched(void);
0369 void            setproc(struct proc*);
0370 void            sleep(void*, struct spinlock*);
0371 void            userinit(void);
0372 int             wait(void);
0373 void            wakeup(void*);
0374 void            yield(void);
0375 int             printpt(int);
0376 
0377 
0378 void            swtch(struct context**, struct context*);
0379 
0380 
0381 void            acquire(struct spinlock*);
0382 void            getcallerpcs(void*, uint*);
0383 int             holding(struct spinlock*);
0384 void            initlock(struct spinlock*, char*);
0385 void            release(struct spinlock*);
0386 void            pushcli(void);
0387 void            popcli(void);
0388 
0389 
0390 void            acquiresleep(struct sleeplock*);
0391 void            releasesleep(struct sleeplock*);
0392 int             holdingsleep(struct sleeplock*);
0393 void            initsleeplock(struct sleeplock*, char*);
0394 
0395 
0396 int             memcmp(const void*, const void*, uint);
0397 void*           memmove(void*, const void*, uint);
0398 void*           memset(void*, int, uint);
0399 char*           safestrcpy(char*, const char*, int);
0400 int             strlen(const char*);
0401 int             strncmp(const char*, const char*, uint);
0402 char*           strncpy(char*, const char*, int);
0403 
0404 
0405 int             argint(int, int*);
0406 int             argptr(int, char**, int);
0407 int             argstr(int, char**);
0408 int             fetchint(uint, int*);
0409 int             fetchstr(uint, char**);
0410 void            syscall(void);
0411 
0412 
0413 void            timerinit(void);
0414 
0415 
0416 void            idtinit(void);
0417 extern uint     ticks;
0418 void            tvinit(void);
0419 extern struct spinlock tickslock;
0420 
0421 
0422 void            uartinit(void);
0423 void            uartintr(void);
0424 void            uartputc(int);
0425 
0426 
0427 void            seginit(void);
0428 void            kvmalloc(void);
0429 pde_t*          setupkvm(void);
0430 char*           uva2ka(pde_t*, char*);
0431 int             allocuvm(pde_t*, uint, uint);
0432 int             deallocuvm(pde_t*, uint, uint);
0433 void            freevm(pde_t*);
0434 void            inituvm(pde_t*, char*, uint);
0435 int             loaduvm(pde_t*, char*, struct inode*, uint, uint);
0436 pde_t*          copyuvm(pde_t*, uint);
0437 void            switchuvm(struct proc*);
0438 void            switchkvm(void);
0439 int             copyout(pde_t*, uint, void*, uint);
0440 void            clearpteu(pde_t *pgdir, char *uva);
0441 
0442 
0443 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
0444 
0445 
0446 
0447 
0448 
0449 
0450 
0451 
0452 static inline uchar
0453 inb(ushort port)
0454 {
0455   uchar data;
0456 
0457   asm volatile("in %1,%0" : "=a" (data) : "d" (port));
0458   return data;
0459 }
0460 
0461 static inline void
0462 insl(int port, void *addr, int cnt)
0463 {
0464   asm volatile("cld; rep insl" :
0465                "=D" (addr), "=c" (cnt) :
0466                "d" (port), "0" (addr), "1" (cnt) :
0467                "memory", "cc");
0468 }
0469 
0470 static inline void
0471 outb(ushort port, uchar data)
0472 {
0473   asm volatile("out %0,%1" : : "a" (data), "d" (port));
0474 }
0475 
0476 static inline void
0477 outw(ushort port, ushort data)
0478 {
0479   asm volatile("out %0,%1" : : "a" (data), "d" (port));
0480 }
0481 
0482 static inline void
0483 outsl(int port, const void *addr, int cnt)
0484 {
0485   asm volatile("cld; rep outsl" :
0486                "=S" (addr), "=c" (cnt) :
0487                "d" (port), "0" (addr), "1" (cnt) :
0488                "cc");
0489 }
0490 
0491 static inline void
0492 stosb(void *addr, int data, int cnt)
0493 {
0494   asm volatile("cld; rep stosb" :
0495                "=D" (addr), "=c" (cnt) :
0496                "0" (addr), "1" (cnt), "a" (data) :
0497                "memory", "cc");
0498 }
0499 
0500 static inline void
0501 stosl(void *addr, int data, int cnt)
0502 {
0503   asm volatile("cld; rep stosl" :
0504                "=D" (addr), "=c" (cnt) :
0505                "0" (addr), "1" (cnt), "a" (data) :
0506                "memory", "cc");
0507 }
0508 
0509 struct segdesc;
0510 
0511 static inline void
0512 lgdt(struct segdesc *p, int size)
0513 {
0514   volatile ushort pd[3];
0515 
0516   pd[0] = size-1;
0517   pd[1] = (uint)p;
0518   pd[2] = (uint)p >> 16;
0519 
0520   asm volatile("lgdt (%0)" : : "r" (pd));
0521 }
0522 
0523 struct gatedesc;
0524 
0525 static inline void
0526 lidt(struct gatedesc *p, int size)
0527 {
0528   volatile ushort pd[3];
0529 
0530   pd[0] = size-1;
0531   pd[1] = (uint)p;
0532   pd[2] = (uint)p >> 16;
0533 
0534   asm volatile("lidt (%0)" : : "r" (pd));
0535 }
0536 
0537 static inline void
0538 ltr(ushort sel)
0539 {
0540   asm volatile("ltr %0" : : "r" (sel));
0541 }
0542 
0543 static inline uint
0544 readeflags(void)
0545 {
0546   uint eflags;
0547   asm volatile("pushfl; popl %0" : "=r" (eflags));
0548   return eflags;
0549 }
0550 static inline void
0551 loadgs(ushort v)
0552 {
0553   asm volatile("movw %0, %%gs" : : "r" (v));
0554 }
0555 
0556 static inline void
0557 cli(void)
0558 {
0559   asm volatile("cli");
0560 }
0561 
0562 static inline void
0563 sti(void)
0564 {
0565   asm volatile("sti");
0566 }
0567 
0568 static inline uint
0569 xchg(volatile uint *addr, uint newval)
0570 {
0571   uint result;
0572 
0573   
0574   asm volatile("lock; xchgl %0, %1" :
0575                "+m" (*addr), "=a" (result) :
0576                "1" (newval) :
0577                "cc");
0578   return result;
0579 }
0580 
0581 static inline uint
0582 rcr2(void)
0583 {
0584   uint val;
0585   asm volatile("movl %%cr2,%0" : "=r" (val));
0586   return val;
0587 }
0588 
0589 static inline void
0590 lcr3(uint val)
0591 {
0592   asm volatile("movl %0,%%cr3" : : "r" (val));
0593 }
0594 
0595 
0596 
0597 
0598 
0599 
0600 
0601 
0602 struct trapframe {
0603   
0604   uint edi;
0605   uint esi;
0606   uint ebp;
0607   uint oesp;      
0608   uint ebx;
0609   uint edx;
0610   uint ecx;
0611   uint eax;
0612 
0613   
0614   ushort gs;
0615   ushort padding1;
0616   ushort fs;
0617   ushort padding2;
0618   ushort es;
0619   ushort padding3;
0620   ushort ds;
0621   ushort padding4;
0622   uint trapno;
0623 
0624   
0625   uint err;
0626   uint eip;
0627   ushort cs;
0628   ushort padding5;
0629   uint eflags;
0630 
0631   
0632   uint esp;
0633   ushort ss;
0634   ushort padding6;
0635 };
0636 
0637 
0638 
0639 
0640 
0641 
0642 
0643 
0644 
0645 
0646 
0647 
0648 
0649 
0650 
0651 
0652 
0653 
0654 #define SEG_NULLASM                                             \
0655         .word 0, 0;                                             \
0656         .byte 0, 0, 0, 0
0657 
0658 
0659 
0660 #define SEG_ASM(type,base,lim)                                  \
0661         .word (((lim) >> 12) & 0xffff), ((base) & 0xffff);      \
0662         .byte (((base) >> 16) & 0xff), (0x90 | (type)),         \
0663                 (0xC0 | (((lim) >> 28) & 0xf)), (((base) >> 24) & 0xff)
0664 
0665 #define STA_X     0x8       
0666 #define STA_E     0x4       
0667 #define STA_C     0x4       
0668 #define STA_W     0x2       
0669 #define STA_R     0x2       
0670 #define STA_A     0x1       
0671 
0672 
0673 
0674 
0675 
0676 
0677 
0678 
0679 
0680 
0681 
0682 
0683 
0684 
0685 
0686 
0687 
0688 
0689 
0690 
0691 
0692 
0693 
0694 
0695 
0696 
0697 
0698 
0699 
0700 
0701 
0702 
0703 
0704 #define FL_CF           0x00000001      
0705 #define FL_PF           0x00000004      
0706 #define FL_AF           0x00000010      
0707 #define FL_ZF           0x00000040      
0708 #define FL_SF           0x00000080      
0709 #define FL_TF           0x00000100      
0710 #define FL_IF           0x00000200      
0711 #define FL_DF           0x00000400      
0712 #define FL_OF           0x00000800      
0713 #define FL_IOPL_MASK    0x00003000      
0714 #define FL_IOPL_0       0x00000000      
0715 #define FL_IOPL_1       0x00001000      
0716 #define FL_IOPL_2       0x00002000      
0717 #define FL_IOPL_3       0x00003000      
0718 #define FL_NT           0x00004000      
0719 #define FL_RF           0x00010000      
0720 #define FL_VM           0x00020000      
0721 #define FL_AC           0x00040000      
0722 #define FL_VIF          0x00080000      
0723 #define FL_VIP          0x00100000      
0724 #define FL_ID           0x00200000      
0725 
0726 
0727 #define CR0_PE          0x00000001      
0728 #define CR0_MP          0x00000002      
0729 #define CR0_EM          0x00000004      
0730 #define CR0_TS          0x00000008      
0731 #define CR0_ET          0x00000010      
0732 #define CR0_NE          0x00000020      
0733 #define CR0_WP          0x00010000      
0734 #define CR0_AM          0x00040000      
0735 #define CR0_NW          0x20000000      
0736 #define CR0_CD          0x40000000      
0737 #define CR0_PG          0x80000000      
0738 
0739 #define CR4_PSE         0x00000010      
0740 
0741 
0742 #define SEG_KCODE 1  
0743 #define SEG_KDATA 2  
0744 #define SEG_UCODE 3  
0745 #define SEG_UDATA 4  
0746 #define SEG_TSS   5  
0747 
0748 
0749 #define NSEGS     6
0750 #ifndef __ASSEMBLER__
0751 
0752 struct segdesc {
0753   uint lim_15_0 : 16;  
0754   uint base_15_0 : 16; 
0755   uint base_23_16 : 8; 
0756   uint type : 4;       
0757   uint s : 1;          
0758   uint dpl : 2;        
0759   uint p : 1;          
0760   uint lim_19_16 : 4;  
0761   uint avl : 1;        
0762   uint rsv1 : 1;       
0763   uint db : 1;         
0764   uint g : 1;          
0765   uint base_31_24 : 8; 
0766 };
0767 
0768 
0769 #define SEG(type, base, lim, dpl) (struct segdesc)    \
0770 { ((lim) >> 12) & 0xffff, (uint)(base) & 0xffff,      \
0771   ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
0772   (uint)(lim) >> 28, 0, 0, 1, 1, (uint)(base) >> 24 }
0773 #define SEG16(type, base, lim, dpl) (struct segdesc)  \
0774 { (lim) & 0xffff, (uint)(base) & 0xffff,              \
0775   ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
0776   (uint)(lim) >> 16, 0, 0, 1, 0, (uint)(base) >> 24 }
0777 #endif
0778 
0779 #define DPL_USER    0x3     
0780 
0781 
0782 #define STA_X       0x8     
0783 #define STA_E       0x4     
0784 #define STA_C       0x4     
0785 #define STA_W       0x2     
0786 #define STA_R       0x2     
0787 #define STA_A       0x1     
0788 
0789 
0790 #define STS_T16A    0x1     
0791 #define STS_LDT     0x2     
0792 #define STS_T16B    0x3     
0793 #define STS_CG16    0x4     
0794 #define STS_TG      0x5     
0795 #define STS_IG16    0x6     
0796 #define STS_TG16    0x7     
0797 #define STS_T32A    0x9     
0798 #define STS_T32B    0xB     
0799 #define STS_CG32    0xC     
0800 #define STS_IG32    0xE     
0801 #define STS_TG32    0xF     
0802 
0803 
0804 
0805 
0806 
0807 
0808 
0809 
0810 
0811 
0812 #define PDX(va)         (((uint)(va) >> PDXSHIFT) & 0x3FF)
0813 
0814 
0815 #define PTX(va)         (((uint)(va) >> PTXSHIFT) & 0x3FF)
0816 
0817 
0818 #define PGADDR(d, t, o) ((uint)((d) << PDXSHIFT | (t) << PTXSHIFT | (o)))
0819 
0820 
0821 #define NPDENTRIES      1024    
0822 #define NPTENTRIES      1024    
0823 #define PGSIZE          4096    
0824 
0825 #define PGSHIFT         12      
0826 #define PTXSHIFT        12      
0827 #define PDXSHIFT        22      
0828 
0829 #define PGROUNDUP(sz)  (((sz)+PGSIZE-1) & ~(PGSIZE-1))
0830 #define PGROUNDDOWN(a) (((a)) & ~(PGSIZE-1))
0831 
0832 
0833 #define PTE_P           0x001   
0834 #define PTE_W           0x002   
0835 #define PTE_U           0x004   
0836 #define PTE_PWT         0x008   
0837 #define PTE_PCD         0x010   
0838 #define PTE_A           0x020   
0839 #define PTE_D           0x040   
0840 #define PTE_PS          0x080   
0841 #define PTE_MBZ         0x180   
0842 
0843 
0844 #define PTE_ADDR(pte)   ((uint)(pte) & ~0xFFF)
0845 #define PTE_FLAGS(pte)  ((uint)(pte) &  0xFFF)
0846 
0847 #ifndef __ASSEMBLER__
0848 typedef uint pte_t;
0849 
0850 
0851 struct taskstate {
0852   uint link;         
0853   uint esp0;         
0854   ushort ss0;        
0855   ushort padding1;
0856   uint *esp1;
0857   ushort ss1;
0858   ushort padding2;
0859   uint *esp2;
0860   ushort ss2;
0861   ushort padding3;
0862   void *cr3;         
0863   uint *eip;         
0864   uint eflags;
0865   uint eax;          
0866   uint ecx;
0867   uint edx;
0868   uint ebx;
0869   uint *esp;
0870   uint *ebp;
0871   uint esi;
0872   uint edi;
0873   ushort es;         
0874   ushort padding4;
0875   ushort cs;
0876   ushort padding5;
0877   ushort ss;
0878   ushort padding6;
0879   ushort ds;
0880   ushort padding7;
0881   ushort fs;
0882   ushort padding8;
0883   ushort gs;
0884   ushort padding9;
0885   ushort ldt;
0886   ushort padding10;
0887   ushort t;          
0888   ushort iomb;       
0889 };
0890 
0891 
0892 
0893 
0894 
0895 
0896 
0897 
0898 
0899 
0900 
0901 struct gatedesc {
0902   uint off_15_0 : 16;   
0903   uint cs : 16;         
0904   uint args : 5;        
0905   uint rsv1 : 3;        
0906   uint type : 4;        
0907   uint s : 1;           
0908   uint dpl : 2;         
0909   uint p : 1;           
0910   uint off_31_16 : 16;  
0911 };
0912 
0913 
0914 
0915 
0916 
0917 
0918 
0919 
0920 
0921 #define SETGATE(gate, istrap, sel, off, d)                \
0922 {                                                         \
0923   (gate).off_15_0 = (uint)(off) & 0xffff;                \
0924   (gate).cs = (sel);                                      \
0925   (gate).args = 0;                                        \
0926   (gate).rsv1 = 0;                                        \
0927   (gate).type = (istrap) ? STS_TG32 : STS_IG32;           \
0928   (gate).s = 0;                                           \
0929   (gate).dpl = (d);                                       \
0930   (gate).p = 1;                                           \
0931   (gate).off_31_16 = (uint)(off) >> 16;                  \
0932 }
0933 
0934 #endif
0935 
0936 
0937 
0938 
0939 
0940 
0941 
0942 
0943 
0944 
0945 
0946 
0947 
0948 
0949 
0950 
0951 
0952 #define ELF_MAGIC 0x464C457FU  
0953 
0954 
0955 struct elfhdr {
0956   uint magic;  
0957   uchar elf[12];
0958   ushort type;
0959   ushort machine;
0960   uint version;
0961   uint entry;
0962   uint phoff;
0963   uint shoff;
0964   uint flags;
0965   ushort ehsize;
0966   ushort phentsize;
0967   ushort phnum;
0968   ushort shentsize;
0969   ushort shnum;
0970   ushort shstrndx;
0971 };
0972 
0973 
0974 struct proghdr {
0975   uint type;
0976   uint off;
0977   uint vaddr;
0978   uint paddr;
0979   uint filesz;
0980   uint memsz;
0981   uint flags;
0982   uint align;
0983 };
0984 
0985 
0986 #define ELF_PROG_LOAD           1
0987 
0988 
0989 #define ELF_PROG_FLAG_EXEC      1
0990 #define ELF_PROG_FLAG_WRITE     2
0991 #define ELF_PROG_FLAG_READ      4
0992 
0993 
0994 
0995 
0996 
0997 
0998 
0999 
1000 
1001 
1002 
1003 
1004 
1005 
1006 
1007 
1008 
1009 
1010 
1011 
1012 
1013 
1014 
1015 
1016 
1017 
1018 
1019 
1020 
1021 
1022 
1023 
1024 
1025 
1026 .p2align 2
1027 .text
1028 .globl multiboot_header
1029 multiboot_header:
1030   
1031   
1032   .long magic
1033   .long flags
1034   .long (-magic-flags)
1035 
1036 
1037 
1038 
1039 .globl _start
1040 _start = V2P_WO(entry)
1041 
1042 .globl wait_main
1043 wait_main:
1044   .long 0
1045 
1046 .globl entry
1047 entry:
1048   
1049   mov $0x10,%ax
1050   mov %ax,%ds
1051   mov %ax,%es
1052   mov %ax,%ss
1053   mov $0,%ax
1054   mov %ax,%fs
1055   mov %ax,%gs
1056 
1057   
1058   movl %cr0,%eax
1059   andl $0x7fffffff,%eax
1060   movl %eax,%cr0
1061 
1062   
1063   movl    $(V2P_WO(entrypgdir)), %eax
1064   movl    %eax, %cr3
1065 
1066   
1067   movl $0x0c0000080,%ecx
1068   rdmsr
1069   andl $0xFFFFFEFF,%eax
1070   wrmsr
1071 
1072   
1073   movl    %cr4, %eax
1074   orl     $(CR4_PSE), %eax
1075   andl    $0xFFFFFFDF, %eax
1076   movl    %eax, %cr4
1077 
1078   
1079   movl    %cr0, %eax
1080   orl     $0x80010001, %eax
1081   movl    %eax, %cr0
1082 
1083 
1084 
1085 
1086   
1087   movl $(stack + KSTACKSIZE), %esp
1088   
1089   
1090   
1091   
1092 
1093   movl $main, %edx
1094   jmp %edx
1095 
1096 .comm stack, KSTACKSIZE
1097 
1098 
1099 
1100 
1101 
1102 
1103 
1104 
1105 
1106 
1107 
1108 
1109 
1110 
1111 
1112 
1113 
1114 
1115 
1116 
1117 
1118 
1119 
1120 
1121 .code16
1122 .globl start
1123 start:
1124   cli
1125 
1126   
1127   xorw    %ax,%ax
1128   movw    %ax,%ds
1129   movw    %ax,%es
1130   movw    %ax,%ss
1131 
1132   
1133   
1134   
1135   lgdt    gdtdesc
1136   movl    %cr0, %eax
1137   orl     $CR0_PE, %eax
1138   movl    %eax, %cr0
1139 
1140   
1141   
1142   
1143   ljmpl    $(SEG_KCODE<<3), $(start32)
1144 
1145 
1146 
1147 
1148 
1149 
1150 .code32  
1151 start32:
1152   
1153   movw    $(SEG_KDATA<<3), %ax    
1154   movw    %ax, %ds                
1155   movw    %ax, %es                
1156   movw    %ax, %ss                
1157   movw    $0, %ax                 
1158   movw    %ax, %fs                
1159   movw    %ax, %gs                
1160 
1161   
1162   movl    %cr4, %eax
1163   orl     $(CR4_PSE), %eax
1164   movl    %eax, %cr4
1165   
1166   movl    (start-12), %eax
1167   movl    %eax, %cr3
1168   
1169   movl    %cr0, %eax
1170   orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
1171   movl    %eax, %cr0
1172 
1173   
1174   movl    (start-4), %esp
1175   
1176   call	 *(start-8)
1177 
1178   movw    $0x8a00, %ax
1179   movw    %ax, %dx
1180   outw    %ax, %dx
1181   movw    $0x8ae0, %ax
1182   outw    %ax, %dx
1183 spin:
1184   jmp     spin
1185 
1186 .p2align 2
1187 gdt:
1188   SEG_NULLASM
1189   SEG_ASM(STA_X|STA_R, 0, 0xffffffff)
1190   SEG_ASM(STA_W, 0, 0xffffffff)
1191 
1192 
1193 gdtdesc:
1194   .word   (gdtdesc - gdt - 1)
1195   .long   gdt
1196 
1197 
1198 
1199 
1200 #include "types.h"
1201 #include "defs.h"
1202 #include "param.h"
1203 #include "memlayout.h"
1204 #include "mmu.h"
1205 #include "proc.h"
1206 #include "x86.h"
1207 #include "mp_uefi.h"
1208 #include "debug.h"
1209 #include "graphic.h"
1210 #include "font.h"
1211 #include "pci.h"
1212 #include "i8254.h"
1213 #include "arp.h"
1214 
1215 static void startothers(void);
1216 static void mpmain(void)  __attribute__((noreturn));
1217 extern pde_t *kpgdir;
1218 extern char end[]; 
1219 
1220 
1221 
1222 
1223 int
1224 main(void)
1225 {
1226   graphic_init();
1227   kinit1(end, P2V(4*1024*1024)); 
1228   kvmalloc();      
1229   mpinit_uefi();
1230   lapicinit();     
1231   seginit();       
1232   picinit();    
1233   ioapicinit();    
1234   consoleinit();   
1235   uartinit();      
1236   pinit();         
1237   tvinit();        
1238   binit();         
1239   fileinit();      
1240   ideinit();       
1241   startothers();   
1242   kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); 
1243   pci_init();
1244   arp_scan();
1245   
1246   userinit();      
1247 
1248   mpmain();        
1249 }
1250 
1251 static void
1252 mpenter(void)
1253 {
1254   switchkvm();
1255   seginit();
1256   lapicinit();
1257   mpmain();
1258 }
1259 
1260 
1261 static void
1262 mpmain(void)
1263 {
1264   cprintf("cpu%d: starting %d\n", cpuid(), cpuid());
1265   idtinit();       
1266   xchg(&(mycpu()->started), 1); 
1267   scheduler();     
1268 }
1269 
1270 pde_t entrypgdir[];  
1271 
1272 
1273 static void
1274 startothers(void)
1275 {
1276   extern uchar _binary_entryother_start[], _binary_entryother_size[];
1277   uchar *code;
1278   struct cpu *c;
1279   char *stack;
1280 
1281   
1282   
1283   
1284   code = P2V(0x7000);
1285   memmove(code, _binary_entryother_start, (uint)_binary_entryother_size);
1286 
1287   for(c = cpus; c < cpus+ncpu; c++){
1288     if(c == mycpu()){  
1289       continue;
1290     }
1291     
1292     
1293     
1294     stack = kalloc();
1295     *(void**)(code-4) = stack + KSTACKSIZE;
1296     *(void**)(code-8) = mpenter;
1297     *(int**)(code-12) = (void *) V2P(entrypgdir);
1298 
1299     lapicstartap(c->apicid, V2P(code));
1300     
1301     while(c->started == 0)
1302       ;
1303   }
1304 }
1305 
1306 
1307 
1308 
1309 
1310 
1311 __attribute__((__aligned__(PGSIZE)))
1312 pde_t entrypgdir[NPDENTRIES] = {
1313   
1314   [0] = (0) | PTE_P | PTE_W | PTE_PS,
1315   
1316   [KERNBASE>>PDXSHIFT] = (0) | PTE_P | PTE_W | PTE_PS,
1317 };
1318 
1319 
1320 
1321 
1322 
1323 
1324 
1325 
1326 
1327 
1328 
1329 
1330 
1331 
1332 
1333 
1334 
1335 
1336 
1337 
1338 
1339 
1340 
1341 
1342 
1343 
1344 
1345 
1346 
1347 
1348 
1349 
1350 
1351 
1352 
1353 
1354 
1355 
1356 
1357 
1358 
1359 
1360 
1361 
1362 
1363 
1364 
1365 
1366 
1367 
1368 
1369 
1370 
1371 
1372 
1373 
1374 
1375 
1376 
1377 
1378 
1379 
1380 
1381 
1382 
1383 
1384 
1385 
1386 
1387 
1388 
1389 
1390 
1391 
1392 
1393 
1394 
1395 
1396 
1397 
1398 
1399 
1400 
1401 
1402 
1403 
1404 
1405 
1406 
1407 
1408 
1409 
1410 
1411 
1412 
1413 
1414 
1415 
1416 
1417 
1418 
1419 
1420 
1421 
1422 
1423 
1424 
1425 
1426 
1427 
1428 
1429 
1430 
1431 
1432 
1433 
1434 
1435 
1436 
1437 
1438 
1439 
1440 
1441 
1442 
1443 
1444 
1445 
1446 
1447 
1448 
1449 
1450 
1451 
1452 
1453 
1454 
1455 
1456 
1457 
1458 
1459 
1460 
1461 
1462 
1463 
1464 
1465 
1466 
1467 
1468 
1469 
1470 
1471 
1472 
1473 
1474 
1475 
1476 
1477 
1478 
1479 
1480 
1481 
1482 
1483 
1484 
1485 
1486 
1487 
1488 
1489 
1490 
1491 
1492 
1493 
1494 
1495 
1496 
1497 
1498 
1499 
1500 
1501 struct spinlock {
1502   uint locked;       
1503 
1504   
1505   char *name;        
1506   struct cpu *cpu;   
1507   uint pcs[10];      
1508                      
1509 };
1510 
1511 
1512 
1513 
1514 
1515 
1516 
1517 
1518 
1519 
1520 
1521 
1522 
1523 
1524 
1525 
1526 
1527 
1528 
1529 
1530 
1531 
1532 
1533 
1534 
1535 
1536 
1537 
1538 
1539 
1540 
1541 
1542 
1543 
1544 
1545 
1546 
1547 
1548 
1549 
1550 
1551 
1552 #include "types.h"
1553 #include "defs.h"
1554 #include "param.h"
1555 #include "x86.h"
1556 #include "memlayout.h"
1557 #include "mmu.h"
1558 #include "proc.h"
1559 #include "spinlock.h"
1560 
1561 void
1562 initlock(struct spinlock *lk, char *name)
1563 {
1564   lk->name = name;
1565   lk->locked = 0;
1566   lk->cpu = 0;
1567 }
1568 
1569 
1570 
1571 
1572 
1573 void
1574 acquire(struct spinlock *lk)
1575 {
1576   pushcli(); 
1577   if(holding(lk)){
1578     panic("acquire");
1579   }
1580 
1581   
1582   while(xchg(&lk->locked, 1) != 0)
1583     ;
1584 
1585   
1586   
1587   
1588   __sync_synchronize();
1589 
1590   
1591   lk->cpu = mycpu();
1592   getcallerpcs(&lk, lk->pcs);
1593 }
1594 
1595 
1596 
1597 
1598 
1599 
1600 
1601 void
1602 release(struct spinlock *lk)
1603 {
1604   if(!holding(lk))
1605     panic("release");
1606 
1607   lk->pcs[0] = 0;
1608   lk->cpu = 0;
1609 
1610   
1611   
1612   
1613   
1614   
1615   __sync_synchronize();
1616 
1617   
1618   
1619   
1620   asm volatile("movl $0, %0" : "+m" (lk->locked) : );
1621 
1622   popcli();
1623 }
1624 
1625 
1626 void
1627 getcallerpcs(void *v, uint pcs[])
1628 {
1629   uint *ebp;
1630   int i;
1631 
1632   ebp = (uint*)v - 2;
1633   for(i = 0; i < 10; i++){
1634     if(ebp == 0 || ebp < (uint*)KERNBASE || ebp == (uint*)0xffffffff)
1635       break;
1636     pcs[i] = ebp[1];     
1637     ebp = (uint*)ebp[0]; 
1638   }
1639   for(; i < 10; i++)
1640     pcs[i] = 0;
1641 }
1642 
1643 
1644 int
1645 holding(struct spinlock *lock)
1646 {
1647   return lock->locked && lock->cpu == mycpu();
1648 }
1649 
1650 
1651 
1652 
1653 
1654 void
1655 pushcli(void)
1656 {
1657   int eflags;
1658 
1659   eflags = readeflags();
1660   cli();
1661   if(mycpu()->ncli == 0)
1662     mycpu()->intena = eflags & FL_IF;
1663   mycpu()->ncli += 1;
1664 }
1665 
1666 void
1667 popcli(void)
1668 {
1669   if(readeflags()&FL_IF)
1670     panic("popcli - interruptible");
1671   if(--mycpu()->ncli < 0)
1672     panic("popcli");
1673   if(mycpu()->ncli == 0 && mycpu()->intena)
1674     sti();
1675 }
1676 
1677 
1678 
1679 
1680 
1681 
1682 
1683 
1684 
1685 
1686 
1687 
1688 
1689 
1690 
1691 
1692 
1693 
1694 
1695 
1696 
1697 
1698 
1699 
1700 #include "param.h"
1701 #include "types.h"
1702 #include "defs.h"
1703 #include "x86.h"
1704 #include "memlayout.h"
1705 #include "mmu.h"
1706 #include "proc.h"
1707 #include "elf.h"
1708 #include "graphic.h"
1709 
1710 extern char data[];  
1711 pde_t *kpgdir;  
1712 
1713 extern struct gpu gpu;
1714 
1715 
1716 void
1717 seginit(void)
1718 {
1719   struct cpu *c;
1720 
1721   
1722   
1723   
1724   
1725   c = &cpus[cpuid()];
1726 
1727   c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
1728   c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
1729   c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
1730   c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
1731   lgdt(c->gdt, sizeof(c->gdt));
1732 }
1733 
1734 
1735 
1736 pte_t *
1737 walkpgdir(pde_t *pgdir, const void *va, int alloc)
1738 {
1739   pde_t *pde;
1740   pte_t *pgtab;
1741 
1742   pde = &pgdir[PDX(va)];
1743   if(*pde & PTE_P){
1744     pgtab = (pte_t*)P2V(PTE_ADDR(*pde));
1745   } else {
1746     if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)
1747       return 0;
1748     
1749     memset(pgtab, 0, PGSIZE);
1750     
1751     
1752     
1753     *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;
1754   }
1755   return &pgtab[PTX(va)];
1756 }
1757 
1758 
1759 
1760 
1761 int
1762 mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)
1763 {
1764   char *a, *last;
1765   pte_t *pte;
1766 
1767   a = (char*)PGROUNDDOWN((uint)va);
1768   last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
1769   for(;;){
1770     if((pte = walkpgdir(pgdir, a, 1)) == 0)
1771       return -1;
1772     if(*pte & PTE_P)
1773       panic("remap");
1774     *pte = pa | perm | PTE_P;
1775     if(a == last)
1776       break;
1777     a += PGSIZE;
1778     pa += PGSIZE;
1779   }
1780   return 0;
1781 }
1782 
1783 
1784 
1785 
1786 
1787 
1788 
1789 
1790 
1791 
1792 
1793 
1794 
1795 
1796 
1797 
1798 
1799 
1800 
1801 
1802 
1803 
1804 
1805 
1806 static struct kmap {
1807   void *virt;
1808   uint phys_start;
1809   uint phys_end;
1810   int perm;
1811 } kmap[] = {
1812  { (void*)KERNBASE, 0,             EXTMEM,    PTE_W}, 
1813  { (void*)KERNLINK, V2P(KERNLINK), V2P(data), 0},     
1814  { (void*)data,     V2P(data),     PHYSTOP,   PTE_W}, 
1815  { 0,0,0,0},
1816  { (void*)(PCI_BAR_BASE + PCI_VP_OFFSET),PCI_BAR_BASE,0x10000000+PCI_BAR_BASE,PTE_W},
1817  { (void*)DEVSPACE, DEVSPACE, 0, PTE_W}, 
1818 };
1819 
1820 
1821 pde_t*
1822 setupkvm(void)
1823 {
1824   pde_t *pgdir;
1825   struct kmap *k;
1826   k = kmap;
1827   struct kmap vram = { (void*)(DEVSPACE - gpu.vram_size),gpu.pvram_addr,gpu.pvram_addr+gpu.vram_size, PTE_W};
1828   k[3] = vram;
1829   if((pgdir = (pde_t*)kalloc()) == 0){
1830     return 0;
1831   }
1832   memset(pgdir, 0, PGSIZE);
1833   if (P2V(PHYSTOP) > (void*)DEVSPACE)
1834     panic("PHYSTOP too high");
1835   for(k = kmap; k < &kmap[NELEM(kmap)]; k++)
1836     if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,
1837                 (uint)k->phys_start, k->perm) < 0) {
1838       freevm(pgdir);
1839       return 0;
1840     }
1841   return pgdir;
1842 }
1843 
1844 
1845 
1846 
1847 
1848 
1849 
1850 
1851 
1852 void
1853 kvmalloc(void)
1854 {
1855   kpgdir = setupkvm();
1856   switchkvm();
1857 }
1858 
1859 
1860 
1861 void
1862 switchkvm(void)
1863 {
1864   lcr3(V2P(kpgdir));   
1865 }
1866 
1867 
1868 void
1869 switchuvm(struct proc *p)
1870 {
1871   if(p == 0)
1872     panic("switchuvm: no process");
1873   if(p->kstack == 0)
1874     panic("switchuvm: no kstack");
1875   if(p->pgdir == 0)
1876     panic("switchuvm: no pgdir");
1877 
1878   pushcli();
1879   mycpu()->gdt[SEG_TSS] = SEG16(STS_T32A, &mycpu()->ts,
1880                                 sizeof(mycpu()->ts)-1, 0);
1881   mycpu()->gdt[SEG_TSS].s = 0;
1882   mycpu()->ts.ss0 = SEG_KDATA << 3;
1883   mycpu()->ts.esp0 = (uint)p->kstack + KSTACKSIZE;
1884   
1885   
1886   mycpu()->ts.iomb = (ushort) 0xFFFF;
1887   ltr(SEG_TSS << 3);
1888   lcr3(V2P(p->pgdir));  
1889   popcli();
1890 }
1891 
1892 
1893 
1894 
1895 
1896 
1897 
1898 
1899 
1900 
1901 
1902 void
1903 inituvm(pde_t *pgdir, char *init, uint sz)
1904 {
1905   char *mem;
1906 
1907   if(sz >= PGSIZE)
1908     panic("inituvm: more than a page");
1909   mem = kalloc();
1910   memset(mem, 0, PGSIZE);
1911   mappages(pgdir, 0, PGSIZE, V2P(mem), PTE_W|PTE_U);
1912   memmove(mem, init, sz);
1913 }
1914 
1915 
1916 
1917 int
1918 loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)
1919 {
1920   uint i, pa, n;
1921   pte_t *pte;
1922 
1923   if((uint) addr % PGSIZE != 0)
1924     panic("loaduvm: addr must be page aligned");
1925   for(i = 0; i < sz; i += PGSIZE){
1926     if((pte = walkpgdir(pgdir, addr+i, 0)) == 0)
1927       panic("loaduvm: address should exist");
1928     pa = PTE_ADDR(*pte);
1929     if(sz - i < PGSIZE)
1930       n = sz - i;
1931     else
1932       n = PGSIZE;
1933     if(readi(ip, P2V(pa), offset+i, n) != n)
1934       return -1;
1935   }
1936   return 0;
1937 }
1938 
1939 
1940 
1941 
1942 
1943 
1944 
1945 
1946 
1947 
1948 
1949 
1950 
1951 
1952 int
1953 allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
1954 {
1955   char *mem;
1956   uint a;
1957 
1958   if(newsz >= KERNBASE)
1959     return 0;
1960   if(newsz < oldsz)
1961     return oldsz;
1962 
1963   a = PGROUNDUP(oldsz);
1964   for(; a < newsz; a += PGSIZE){
1965     mem = kalloc();
1966     if(mem == 0){
1967       cprintf("allocuvm out of memory\n");
1968       deallocuvm(pgdir, newsz, oldsz);
1969       return 0;
1970     }
1971     memset(mem, 0, PGSIZE);
1972     if(mappages(pgdir, (char*)a, PGSIZE, V2P(mem), PTE_W|PTE_U) < 0){
1973       cprintf("allocuvm out of memory (2)\n");
1974       deallocuvm(pgdir, newsz, oldsz);
1975       kfree(mem);
1976       return 0;
1977     }
1978   }
1979   return newsz;
1980 }
1981 
1982 
1983 
1984 
1985 
1986 int
1987 deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
1988 {
1989   pte_t *pte;
1990   uint a, pa;
1991 
1992   if(newsz >= oldsz)
1993     return oldsz;
1994 
1995   a = PGROUNDUP(newsz);
1996   for(; a  < oldsz; a += PGSIZE){
1997     pte = walkpgdir(pgdir, (char*)a, 0);
1998     if(!pte)
1999       a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;
2000     else if((*pte & PTE_P) != 0){
2001       pa = PTE_ADDR(*pte);
2002       if(pa == 0)
2003         panic("kfree");
2004       char *v = P2V(pa);
2005       kfree(v);
2006       *pte = 0;
2007     }
2008   }
2009   return newsz;
2010 }
2011 
2012 
2013 
2014 void
2015 freevm(pde_t *pgdir)
2016 {
2017   uint i;
2018 
2019   if(pgdir == 0)
2020     panic("freevm: no pgdir");
2021   deallocuvm(pgdir, KERNBASE, 0);
2022   for(i = 0; i < NPDENTRIES; i++){
2023     if(pgdir[i] & PTE_P){
2024       char * v = P2V(PTE_ADDR(pgdir[i]));
2025       kfree(v);
2026     }
2027   }
2028   kfree((char*)pgdir);
2029 }
2030 
2031 
2032 
2033 void
2034 clearpteu(pde_t *pgdir, char *uva)
2035 {
2036   pte_t *pte;
2037 
2038   pte = walkpgdir(pgdir, uva, 0);
2039   if(pte == 0)
2040     panic("clearpteu");
2041   *pte &= ~PTE_U;
2042 }
2043 
2044 
2045 
2046 
2047 
2048 
2049 
2050 
2051 
2052 pde_t*
2053 copyuvm(pde_t *pgdir, uint sz)
2054 {
2055   pde_t *d;
2056   pte_t *pte;
2057   uint pa, i, flags;
2058   char *mem;
2059 
2060   if((d = setupkvm()) == 0)
2061     return 0;
2062   for(i = 0; i < sz; i += PGSIZE){
2063     if((pte = walkpgdir(pgdir, (void *) i, 0)) == 0)
2064       panic("copyuvm: pte should exist");
2065     if(!(*pte & PTE_P))
2066       panic("copyuvm: page not present");
2067     pa = PTE_ADDR(*pte);
2068     flags = PTE_FLAGS(*pte);
2069     if((mem = kalloc()) == 0)
2070       goto bad;
2071     memmove(mem, (char*)P2V(pa), PGSIZE);
2072     if(mappages(d, (void*)i, PGSIZE, V2P(mem), flags) < 0)
2073       goto bad;
2074   }
2075   return d;
2076 
2077 bad:
2078   freevm(d);
2079   return 0;
2080 }
2081 
2082 
2083 
2084 
2085 
2086 
2087 
2088 
2089 
2090 
2091 
2092 
2093 
2094 
2095 
2096 
2097 
2098 
2099 
2100 
2101 char*
2102 uva2ka(pde_t *pgdir, char *uva)
2103 {
2104   pte_t *pte;
2105 
2106   pte = walkpgdir(pgdir, uva, 0);
2107   if((*pte & PTE_P) == 0)
2108     return 0;
2109   if((*pte & PTE_U) == 0)
2110     return 0;
2111   return (char*)P2V(PTE_ADDR(*pte));
2112 }
2113 
2114 
2115 
2116 
2117 int
2118 copyout(pde_t *pgdir, uint va, void *p, uint len)
2119 {
2120   char *buf, *pa0;
2121   uint n, va0;
2122 
2123   buf = (char*)p;
2124   while(len > 0){
2125     va0 = (uint)PGROUNDDOWN(va);
2126     pa0 = uva2ka(pgdir, (char*)va0);
2127     if(pa0 == 0)
2128       return -1;
2129     n = PGSIZE - (va - va0);
2130     if(n > len)
2131       n = len;
2132     memmove(pa0 + (va - va0), buf, n);
2133     len -= n;
2134     buf += n;
2135     va = va0 + PGSIZE;
2136   }
2137   return 0;
2138 }
2139 
2140 
2141 
2142 
2143 
2144 
2145 
2146 
2147 
2148 
2149 
2150 
2151 
2152 
2153 
2154 
2155 
2156 
2157 
2158 
2159 
2160 
2161 
2162 
2163 
2164 
2165 
2166 
2167 
2168 
2169 
2170 
2171 
2172 
2173 
2174 
2175 
2176 
2177 
2178 
2179 
2180 
2181 
2182 
2183 
2184 
2185 
2186 
2187 
2188 
2189 
2190 
2191 
2192 
2193 
2194 
2195 
2196 
2197 
2198 
2199 
2200 
2201 
2202 
2203 
2204 
2205 
2206 
2207 
2208 
2209 
2210 
2211 
2212 
2213 
2214 
2215 
2216 
2217 
2218 
2219 
2220 
2221 
2222 
2223 
2224 
2225 
2226 
2227 
2228 
2229 
2230 
2231 
2232 
2233 
2234 
2235 
2236 
2237 
2238 
2239 
2240 
2241 
2242 
2243 
2244 
2245 
2246 
2247 
2248 
2249 
2250 
2251 
2252 
2253 
2254 
2255 
2256 
2257 
2258 
2259 
2260 
2261 
2262 
2263 
2264 
2265 
2266 
2267 
2268 
2269 
2270 
2271 
2272 
2273 
2274 
2275 
2276 
2277 
2278 
2279 
2280 
2281 
2282 
2283 
2284 
2285 
2286 
2287 
2288 
2289 
2290 
2291 
2292 
2293 
2294 
2295 
2296 
2297 
2298 
2299 
2300 
2301 struct cpu {
2302   uchar apicid;                
2303   struct context *scheduler;   
2304   struct taskstate ts;         
2305   struct segdesc gdt[NSEGS];   
2306   volatile uint started;       
2307   int ncli;                    
2308   int intena;                  
2309   struct proc *proc;           
2310 };
2311 
2312 extern struct cpu cpus[NCPU];
2313 extern int ncpu;
2314 
2315 
2316 
2317 
2318 
2319 
2320 
2321 
2322 
2323 
2324 
2325 
2326 struct context {
2327   uint edi;
2328   uint esi;
2329   uint ebx;
2330   uint ebp;
2331   uint eip;
2332 };
2333 
2334 enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
2335 
2336 
2337 struct proc {
2338   uint sz;                     
2339   pde_t* pgdir;                
2340   char *kstack;                
2341   enum procstate state;        
2342   int pid;                     
2343   struct proc *parent;         
2344   struct trapframe *tf;        
2345   struct context *context;     
2346   void *chan;                  
2347   int killed;                  
2348   struct file *ofile[NOFILE];  
2349   struct inode *cwd;           
2350   char name[16];               
2351   uint stack_size;
2352 };
2353 
2354 
2355 
2356 
2357 
2358 
2359 
2360 
2361 
2362 
2363 
2364 
2365 
2366 
2367 
2368 
2369 
2370 
2371 
2372 
2373 
2374 
2375 
2376 
2377 
2378 
2379 
2380 
2381 
2382 
2383 
2384 
2385 
2386 
2387 
2388 
2389 
2390 
2391 
2392 
2393 
2394 
2395 
2396 
2397 
2398 
2399 
2400 #include "types.h"
2401 #include "defs.h"
2402 #include "param.h"
2403 #include "memlayout.h"
2404 #include "mmu.h"
2405 #include "x86.h"
2406 #include "proc.h"
2407 #include "spinlock.h"
2408 #include "debug.h"
2409 
2410 pte_t * walkpgdir(pde_t *pgdir, const void *va, int alloc);
2411 
2412 struct {
2413   struct spinlock lock;
2414   struct proc proc[NPROC];
2415 } ptable;
2416 
2417 static struct proc *initproc;
2418 
2419 int nextpid = 1;
2420 extern void forkret(void);
2421 extern void trapret(void);
2422 
2423 static void wakeup1(void *chan);
2424 
2425 void
2426 pinit(void)
2427 {
2428   initlock(&ptable.lock, "ptable");
2429 }
2430 
2431 
2432 int
2433 cpuid() {
2434   return mycpu()-cpus;
2435 }
2436 
2437 
2438 
2439 
2440 
2441 
2442 
2443 
2444 
2445 
2446 
2447 
2448 
2449 
2450 
2451 
2452 struct cpu*
2453 mycpu(void)
2454 {
2455   int apicid, i;
2456 
2457   if(readeflags()&FL_IF){
2458     panic("mycpu called with interrupts enabled\n");
2459   }
2460 
2461   apicid = lapicid();
2462   
2463   
2464   for (i = 0; i < ncpu; ++i) {
2465     if (cpus[i].apicid == apicid){
2466       return &cpus[i];
2467     }
2468   }
2469   panic("unknown apicid\n");
2470 }
2471 
2472 
2473 
2474 struct proc*
2475 myproc(void) {
2476   struct cpu *c;
2477   struct proc *p;
2478   pushcli();
2479   c = mycpu();
2480   p = c->proc;
2481   popcli();
2482   return p;
2483 }
2484 
2485 
2486 
2487 
2488 
2489 
2490 
2491 
2492 
2493 
2494 
2495 
2496 
2497 
2498 
2499 
2500 
2501 
2502 
2503 
2504 static struct proc*
2505 allocproc(void)
2506 {
2507   struct proc *p;
2508   char *sp;
2509 
2510   acquire(&ptable.lock);
2511 
2512   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
2513     if(p->state == UNUSED){
2514       goto found;
2515     }
2516 
2517   release(&ptable.lock);
2518   return 0;
2519 
2520 found:
2521   p->state = EMBRYO;
2522   p->pid = nextpid++;
2523 
2524   release(&ptable.lock);
2525 
2526 
2527   
2528   if((p->kstack = kalloc()) == 0){
2529     p->state = UNUSED;
2530     return 0;
2531   }
2532   sp = p->kstack + KSTACKSIZE;
2533 
2534   
2535   sp -= sizeof *p->tf;
2536   p->tf = (struct trapframe*)sp;
2537 
2538   
2539   
2540   sp -= 4;
2541   *(uint*)sp = (uint)trapret;
2542 
2543   sp -= sizeof *p->context;
2544   p->context = (struct context*)sp;
2545   memset(p->context, 0, sizeof *p->context);
2546   p->context->eip = (uint)forkret;
2547 
2548   return p;
2549 }
2550 
2551 
2552 void
2553 userinit(void)
2554 {
2555   struct proc *p;
2556   extern char _binary_initcode_start[], _binary_initcode_size[];
2557 
2558   p = allocproc();
2559 
2560   initproc = p;
2561   if((p->pgdir = setupkvm()) == 0){
2562     panic("userinit: out of memory?");
2563   }
2564   inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
2565   p->sz = PGSIZE;
2566   memset(p->tf, 0, sizeof(*p->tf));
2567   p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
2568   p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
2569   p->tf->es = p->tf->ds;
2570   p->tf->ss = p->tf->ds;
2571   p->tf->eflags = FL_IF;
2572   p->tf->esp = PGSIZE;
2573   p->tf->eip = 0;  
2574 
2575   safestrcpy(p->name, "initcode", sizeof(p->name));
2576   p->cwd = namei("/");
2577 
2578   
2579   
2580   
2581   
2582   acquire(&ptable.lock);
2583 
2584   p->state = RUNNABLE;
2585 
2586   release(&ptable.lock);
2587 }
2588 
2589 
2590 
2591 
2592 
2593 
2594 
2595 
2596 
2597 
2598 
2599 
2600 
2601 
2602 int
2603 growproc(int n)
2604 {
2605   uint sz;
2606   struct proc *curproc = myproc();
2607 
2608   sz = curproc->sz;
2609   if(n > 0){
2610     if((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
2611       return -1;
2612   } else if(n < 0){
2613     if((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
2614       return -1;
2615   }
2616   curproc->sz = sz;
2617   switchuvm(curproc);
2618   return 0;
2619 }
2620 
2621 
2622 
2623 
2624 int
2625 fork(void)
2626 {
2627   int i, pid;
2628   struct proc *np;
2629   struct proc *curproc = myproc();
2630 
2631   
2632   if((np = allocproc()) == 0){
2633     return -1;
2634   }
2635 
2636   
2637   if((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0){
2638     kfree(np->kstack);
2639     np->kstack = 0;
2640     np->state = UNUSED;
2641     return -1;
2642   }
2643   np->sz = curproc->sz;
2644   np->parent = curproc;
2645   *np->tf = *curproc->tf;
2646 
2647   
2648   np->tf->eax = 0;
2649 
2650   for(i = 0; i < NOFILE; i++)
2651     if(curproc->ofile[i])
2652       np->ofile[i] = filedup(curproc->ofile[i]);
2653   np->cwd = idup(curproc->cwd);
2654 
2655   safestrcpy(np->name, curproc->name, sizeof(curproc->name));
2656 
2657   pid = np->pid;
2658 
2659   acquire(&ptable.lock);
2660 
2661   np->state = RUNNABLE;
2662 
2663   release(&ptable.lock);
2664 
2665   return pid;
2666 }
2667 
2668 
2669 
2670 
2671 void
2672 exit(void)
2673 {
2674   struct proc *curproc = myproc();
2675   struct proc *p;
2676   int fd;
2677 
2678   if(curproc == initproc)
2679     panic("init exiting");
2680 
2681   
2682   for(fd = 0; fd < NOFILE; fd++){
2683     if(curproc->ofile[fd]){
2684       fileclose(curproc->ofile[fd]);
2685       curproc->ofile[fd] = 0;
2686     }
2687   }
2688 
2689   begin_op();
2690   iput(curproc->cwd);
2691   end_op();
2692   curproc->cwd = 0;
2693 
2694   acquire(&ptable.lock);
2695 
2696   
2697   wakeup1(curproc->parent);
2698 
2699 
2700   
2701   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2702     if(p->parent == curproc){
2703       p->parent = initproc;
2704       if(p->state == ZOMBIE)
2705         wakeup1(initproc);
2706     }
2707   }
2708 
2709   
2710   curproc->state = ZOMBIE;
2711   sched();
2712   panic("zombie exit");
2713 }
2714 
2715 
2716 
2717 int
2718 wait(void)
2719 {
2720   struct proc *p;
2721   int havekids, pid;
2722   struct proc *curproc = myproc();
2723 
2724   acquire(&ptable.lock);
2725   for(;;){
2726     
2727     havekids = 0;
2728     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2729       if(p->parent != curproc)
2730         continue;
2731       havekids = 1;
2732       if(p->state == ZOMBIE){
2733         
2734         pid = p->pid;
2735         kfree(p->kstack);
2736         p->kstack = 0;
2737         freevm(p->pgdir);
2738         p->pid = 0;
2739         p->parent = 0;
2740         p->name[0] = 0;
2741         p->killed = 0;
2742         p->state = UNUSED;
2743         release(&ptable.lock);
2744         return pid;
2745       }
2746     }
2747 
2748 
2749 
2750     
2751     if(!havekids || curproc->killed){
2752       release(&ptable.lock);
2753       return -1;
2754     }
2755 
2756     
2757     sleep(curproc, &ptable.lock);  
2758   }
2759 }
2760 
2761 
2762 
2763 
2764 
2765 
2766 
2767 
2768 
2769 
2770 
2771 
2772 
2773 
2774 
2775 
2776 
2777 
2778 
2779 
2780 
2781 
2782 
2783 
2784 
2785 
2786 
2787 
2788 
2789 
2790 
2791 
2792 
2793 
2794 
2795 
2796 
2797 
2798 
2799 
2800 
2801 
2802 
2803 
2804 
2805 
2806 
2807 void
2808 scheduler(void)
2809 {
2810   struct proc *p;
2811   struct cpu *c = mycpu();
2812   c->proc = 0;
2813 
2814   for(;;){
2815     
2816     sti();
2817 
2818     
2819     acquire(&ptable.lock);
2820     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2821       if(p->state != RUNNABLE)
2822         continue;
2823 
2824       
2825       
2826       
2827       c->proc = p;
2828       switchuvm(p);
2829       p->state = RUNNING;
2830 
2831       swtch(&(c->scheduler), p->context);
2832       switchkvm();
2833 
2834       
2835       
2836       c->proc = 0;
2837     }
2838     release(&ptable.lock);
2839 
2840   }
2841 }
2842 
2843 
2844 
2845 
2846 
2847 
2848 
2849 
2850 
2851 
2852 
2853 
2854 
2855 
2856 
2857 void
2858 sched(void)
2859 {
2860   int intena;
2861   struct proc *p = myproc();
2862 
2863   if(!holding(&ptable.lock))
2864     panic("sched ptable.lock");
2865   if(mycpu()->ncli != 1)
2866     panic("sched locks");
2867   if(p->state == RUNNING)
2868     panic("sched running");
2869   if(readeflags()&FL_IF)
2870     panic("sched interruptible");
2871   intena = mycpu()->intena;
2872   swtch(&p->context, mycpu()->scheduler);
2873   mycpu()->intena = intena;
2874 }
2875 
2876 
2877 void
2878 yield(void)
2879 {
2880   acquire(&ptable.lock);  
2881   myproc()->state = RUNNABLE;
2882   sched();
2883   release(&ptable.lock);
2884 }
2885 
2886 
2887 
2888 
2889 
2890 
2891 
2892 
2893 
2894 
2895 
2896 
2897 
2898 
2899 
2900 
2901 
2902 void
2903 forkret(void)
2904 {
2905   static int first = 1;
2906   
2907   release(&ptable.lock);
2908 
2909   if (first) {
2910     
2911     
2912     
2913     first = 0;
2914     iinit(ROOTDEV);
2915     initlog(ROOTDEV);
2916   }
2917 
2918   
2919 }
2920 
2921 
2922 
2923 void
2924 sleep(void *chan, struct spinlock *lk)
2925 {
2926   struct proc *p = myproc();
2927 
2928   if(p == 0)
2929     panic("sleep");
2930 
2931   if(lk == 0)
2932     panic("sleep without lk");
2933 
2934   
2935   
2936   
2937   
2938   
2939   
2940   if(lk != &ptable.lock){  
2941     acquire(&ptable.lock);  
2942     release(lk);
2943   }
2944   
2945   p->chan = chan;
2946   p->state = SLEEPING;
2947 
2948   sched();
2949 
2950   
2951   p->chan = 0;
2952 
2953   
2954   if(lk != &ptable.lock){  
2955     release(&ptable.lock);
2956     acquire(lk);
2957   }
2958 }
2959 
2960 
2961 
2962 
2963 
2964 
2965 
2966 
2967 
2968 
2969 
2970 
2971 
2972 
2973 
2974 
2975 
2976 
2977 
2978 
2979 
2980 
2981 
2982 
2983 
2984 
2985 
2986 
2987 
2988 
2989 
2990 
2991 
2992 
2993 
2994 
2995 
2996 
2997 
2998 
2999 
3000 
3001 
3002 static void
3003 wakeup1(void *chan)
3004 {
3005   struct proc *p;
3006 
3007   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
3008     if(p->state == SLEEPING && p->chan == chan)
3009       p->state = RUNNABLE;
3010 }
3011 
3012 
3013 void
3014 wakeup(void *chan)
3015 {
3016   acquire(&ptable.lock);
3017   wakeup1(chan);
3018   release(&ptable.lock);
3019 }
3020 
3021 
3022 
3023 
3024 int
3025 kill(int pid)
3026 {
3027   struct proc *p;
3028 
3029   acquire(&ptable.lock);
3030   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
3031     if(p->pid == pid){
3032       p->killed = 1;
3033       
3034       if(p->state == SLEEPING)
3035         p->state = RUNNABLE;
3036       release(&ptable.lock);
3037       return 0;
3038     }
3039   }
3040   release(&ptable.lock);
3041   return -1;
3042 }
3043 
3044 
3045 
3046 
3047 
3048 
3049 
3050 
3051 
3052 
3053 void
3054 procdump(void)
3055 {
3056   static char *states[] = {
3057   [UNUSED]    "unused",
3058   [EMBRYO]    "embryo",
3059   [SLEEPING]  "sleep ",
3060   [RUNNABLE]  "runble",
3061   [RUNNING]   "run   ",
3062   [ZOMBIE]    "zombie"
3063   };
3064   int i;
3065   struct proc *p;
3066   char *state;
3067   uint pc[10];
3068 
3069   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
3070     if(p->state == UNUSED)
3071       continue;
3072     if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
3073       state = states[p->state];
3074     else
3075       state = "???";
3076     cprintf("%d %s %s", p->pid, state, p->name);
3077     if(p->state == SLEEPING){
3078       getcallerpcs((uint*)p->context->ebp+2, pc);
3079       for(i=0; i<10 && pc[i] != 0; i++)
3080         cprintf(" %p", pc[i]);
3081     }
3082     cprintf("\n");
3083   }
3084 }
3085 
3086 
3087 
3088 
3089 
3090 
3091 
3092 
3093 
3094 
3095 
3096 
3097 
3098 
3099 
3100 int
3101 printpt(int pid)
3102 {
3103 
3104   struct proc *p;
3105   pte_t *pgdir = 0;
3106   acquire(&ptable.lock);
3107   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
3108     if(p->pid == pid) {
3109       pgdir = p->pgdir;
3110       break;
3111     }
3112   }
3113   release(&ptable.lock);
3114 
3115 
3116   cprintf("START PAGE TABLE (pid %d)\n", pid);
3117 
3118   for (int i = 0; i < 512; i++) { 
3119       if (pgdir[i] & PTE_P) {   
3120           pte_t *pte;
3121           for (int j = 0; j < NPTENTRIES; j++) {
3122               void *va = (void *)((i << 22) | (j << 12));  
3123               pte = walkpgdir(pgdir, va, 0);
3124               if (pte[j] & PTE_P) {
3125                   cprintf("pte[j] = %x\n", pte[j]);
3126                   cprintf("%x P %s %s %x\n",
3127                           i * NPTENTRIES + j,
3128                           (pte[j] & PTE_U) ? "U" : "K",
3129                           (pte[j] & PTE_W) ? "W" : "-",
3130                           PTE_ADDR(pte[j]) >> PTXSHIFT);
3131                           
3132               }
3133           }
3134       }
3135   }
3136   cprintf("END PAGE TABLE\n");
3137 
3138   lcr3(V2P(myproc()->pgdir)); 
3139 
3140   return 0;
3141 }
3142 
3143 
3144 
3145 
3146 
3147 
3148 
3149 
3150 
3151 
3152 
3153 
3154 
3155 
3156 
3157 
3158 .globl swtch
3159 swtch:
3160   movl 4(%esp), %eax
3161   movl 8(%esp), %edx
3162 
3163   
3164   pushl %ebp
3165   pushl %ebx
3166   pushl %esi
3167   pushl %edi
3168 
3169   
3170   movl %esp, (%eax)
3171   movl %edx, %esp
3172 
3173   
3174   popl %edi
3175   popl %esi
3176   popl %ebx
3177   popl %ebp
3178   ret
3179 
3180 
3181 
3182 
3183 
3184 
3185 
3186 
3187 
3188 
3189 
3190 
3191 
3192 
3193 
3194 
3195 
3196 
3197 
3198 
3199 
3200 
3201 
3202 
3203 
3204 #include "types.h"
3205 #include "defs.h"
3206 #include "param.h"
3207 #include "memlayout.h"
3208 #include "mmu.h"
3209 #include "spinlock.h"
3210 
3211 void freerange(void *vstart, void *vend);
3212 extern char end[]; 
3213                    
3214 
3215 struct run {
3216   struct run *next;
3217 };
3218 
3219 struct {
3220   struct spinlock lock;
3221   int use_lock;
3222   struct run *freelist;
3223 } kmem;
3224 
3225 
3226 
3227 
3228 
3229 
3230 void
3231 kinit1(void *vstart, void *vend)
3232 {
3233   initlock(&kmem.lock, "kmem");
3234   kmem.use_lock = 0;
3235   freerange(vstart, vend);
3236 }
3237 
3238 void
3239 kinit2(void *vstart, void *vend)
3240 {
3241   freerange(vstart, vend);
3242   kmem.use_lock = 1;
3243 }
3244 
3245 
3246 
3247 
3248 
3249 
3250 void
3251 freerange(void *vstart, void *vend)
3252 {
3253   char *p;
3254   p = (char*)PGROUNDUP((uint)vstart);
3255   for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
3256     kfree(p);
3257 }
3258 
3259 
3260 
3261 
3262 
3263 void
3264 kfree(char *v)
3265 {
3266   struct run *r;
3267 
3268   if((uint)v % PGSIZE || v < end || V2P(v) >= PHYSTOP)
3269     panic("kfree");
3270 
3271   
3272   memset(v, 1, PGSIZE);
3273 
3274   if(kmem.use_lock)
3275     acquire(&kmem.lock);
3276   r = (struct run*)v;
3277   r->next = kmem.freelist;
3278   kmem.freelist = r;
3279   if(kmem.use_lock)
3280     release(&kmem.lock);
3281 }
3282 
3283 
3284 
3285 
3286 char*
3287 kalloc(void)
3288 {
3289   struct run *r;
3290 
3291   if(kmem.use_lock)
3292     acquire(&kmem.lock);
3293   r = kmem.freelist;
3294   if(r)
3295     kmem.freelist = r->next;
3296   if(kmem.use_lock)
3297     release(&kmem.lock);
3298   return (char*)r;
3299 }
3300 
3301 
3302 
3303 #define T_DIVIDE         0      
3304 #define T_DEBUG          1      
3305 #define T_NMI            2      
3306 #define T_BRKPT          3      
3307 #define T_OFLOW          4      
3308 #define T_BOUND          5      
3309 #define T_ILLOP          6      
3310 #define T_DEVICE         7      
3311 #define T_DBLFLT         8      
3312 
3313 #define T_TSS           10      
3314 #define T_SEGNP         11      
3315 #define T_STACK         12      
3316 #define T_GPFLT         13      
3317 #define T_PGFLT         14      
3318 
3319 #define T_FPERR         16      
3320 #define T_ALIGN         17      
3321 #define T_MCHK          18      
3322 #define T_SIMDERR       19      
3323 
3324 
3325 
3326 #define T_SYSCALL       64      
3327 #define T_DEFAULT      500      
3328 
3329 #define T_IRQ0          32      
3330 
3331 #define IRQ_TIMER        0
3332 #define IRQ_KBD          1
3333 #define IRQ_COM1         4
3334 #define IRQ_IDE         14
3335 #define IRQ_ERROR       19
3336 #define IRQ_SPURIOUS    31
3337 
3338 
3339 
3340 
3341 
3342 
3343 
3344 
3345 
3346 
3347 
3348 
3349 
3350 #!/usr/bin/perl -w
3351 
3352 # Generate vectors.S, the trap/interrupt entry points.
3353 # There has to be one entry point per interrupt number
3354 # since otherwise there's no way for trap() to discover
3355 # the interrupt number.
3356 
3357 print "# generated by vectors.pl - do not edit\n";
3358 print "# handlers\n";
3359 print ".globl alltraps\n";
3360 for(my $i = 0; $i < 256; $i++){
3361     print ".globl vector$i\n";
3362     print "vector$i:\n";
3363     if(!($i == 8 || ($i >= 10 && $i <= 14) || $i == 17)){
3364         print "  pushl \$0\n";
3365     }
3366     print "  pushl \$$i\n";
3367     print "  jmp alltraps\n";
3368 }
3369 
3370 print "\n# vector table\n";
3371 print ".data\n";
3372 print ".globl vectors\n";
3373 print "vectors:\n";
3374 for(my $i = 0; $i < 256; $i++){
3375     print "  .long vector$i\n";
3376 }
3377 
3378 # sample output:
3379 #   # handlers
3380 #   .globl alltraps
3381 #   .globl vector0
3382 #   vector0:
3383 #     pushl $0
3384 #     pushl $0
3385 #     jmp alltraps
3386 #   ...
3387 #
3388 #   # vector table
3389 #   .data
3390 #   .globl vectors
3391 #   vectors:
3392 #     .long vector0
3393 #     .long vector1
3394 #     .long vector2
3395 #   ...
3396 
3397 
3398 
3399 
3400 
3401 
3402   
3403 .globl alltraps
3404 alltraps:
3405   
3406   pushl %ds
3407   pushl %es
3408   pushl %fs
3409   pushl %gs
3410   pushal
3411 
3412   
3413   movw $(SEG_KDATA<<3), %ax
3414   movw %ax, %ds
3415   movw %ax, %es
3416 
3417   
3418   pushl %esp
3419   call trap
3420   addl $4, %esp
3421 
3422   
3423 .globl trapret
3424 trapret:
3425   popal
3426   popl %gs
3427   popl %fs
3428   popl %es
3429   popl %ds
3430   addl $0x8, %esp  
3431   iret
3432 
3433 
3434 
3435 
3436 
3437 
3438 
3439 
3440 
3441 
3442 
3443 
3444 
3445 
3446 
3447 
3448 
3449 
3450 #include "types.h"
3451 #include "defs.h"
3452 #include "param.h"
3453 #include "memlayout.h"
3454 #include "mmu.h"
3455 #include "proc.h"
3456 #include "x86.h"
3457 #include "traps.h"
3458 #include "spinlock.h"
3459 #include "i8254.h"
3460 
3461 
3462 struct gatedesc idt[256];
3463 extern uint vectors[];  
3464 struct spinlock tickslock;
3465 uint ticks;
3466 
3467 void
3468 tvinit(void)
3469 {
3470   int i;
3471 
3472   for(i = 0; i < 256; i++)
3473     SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);
3474   SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
3475 
3476   initlock(&tickslock, "time");
3477 }
3478 
3479 void
3480 idtinit(void)
3481 {
3482   lidt(idt, sizeof(idt));
3483 }
3484 
3485 
3486 
3487 
3488 
3489 
3490 
3491 
3492 
3493 
3494 
3495 
3496 
3497 
3498 
3499 
3500 void
3501 trap(struct trapframe *tf)
3502 {
3503   if(tf->trapno == T_SYSCALL){
3504     if(myproc()->killed)
3505       exit();
3506     myproc()->tf = tf;
3507     syscall();
3508     if(myproc()->killed)
3509       exit();
3510     return;
3511   }
3512 
3513   switch(tf->trapno){
3514   case T_IRQ0 + IRQ_TIMER:
3515     if(cpuid() == 0){
3516       acquire(&tickslock);
3517       ticks++;
3518       wakeup(&ticks);
3519       release(&tickslock);
3520     }
3521     lapiceoi();
3522     break;
3523   case T_IRQ0 + IRQ_IDE:
3524     ideintr();
3525     lapiceoi();
3526     break;
3527   case T_IRQ0 + IRQ_IDE+1:
3528     
3529     break;
3530   case T_IRQ0 + IRQ_KBD:
3531     kbdintr();
3532     lapiceoi();
3533     break;
3534   case T_IRQ0 + IRQ_COM1:
3535     uartintr();
3536     lapiceoi();
3537     break;
3538   case T_IRQ0 + 0xB:
3539     i8254_intr();
3540     lapiceoi();
3541     break;
3542   case T_IRQ0 + IRQ_SPURIOUS:
3543     cprintf("cpu%d: spurious interrupt at %x:%x\n",
3544             cpuid(), tf->cs, tf->eip);
3545     lapiceoi();
3546     break;
3547 
3548 
3549 
3550   case T_PGFLT:
3551     uint va = PGROUNDDOWN(rcr2());
3552     struct proc *curproc = myproc();
3553 
3554     if(va >= KERNBASE - curproc->stack_size - PGSIZE) {
3555       if(allocuvm(curproc->pgdir, va, va + PGSIZE) == 0) {
3556         cprintf("trap: page fault at 0x%x, process killed\n", rcr2());
3557         curproc->killed = 1;
3558       } else {
3559         curproc->stack_size += PGSIZE;
3560         lcr3(V2P(myproc()->pgdir)); 
3561       }
3562       return;
3563     }
3564 
3565 
3566   default:
3567     if(myproc() == 0 || (tf->cs&3) == 0){
3568       
3569       cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
3570               tf->trapno, cpuid(), tf->eip, rcr2());
3571       panic("trap");
3572     }
3573     
3574     cprintf("pid %d %s: trap %d err %d on cpu %d "
3575             "eip 0x%x addr 0x%x--kill proc\n",
3576             myproc()->pid, myproc()->name, tf->trapno,
3577             tf->err, cpuid(), tf->eip, rcr2());
3578     myproc()->killed = 1;
3579   }
3580 
3581   
3582   
3583   
3584   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
3585     exit();
3586 
3587   
3588   
3589   if(myproc() && myproc()->state == RUNNING &&
3590      tf->trapno == T_IRQ0+IRQ_TIMER)
3591     yield();
3592 
3593   
3594   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
3595     exit();
3596 }
3597 
3598 
3599 
3600 
3601 #define SYS_fork    1
3602 #define SYS_exit    2
3603 #define SYS_wait    3
3604 #define SYS_pipe    4
3605 #define SYS_read    5
3606 #define SYS_kill    6
3607 #define SYS_exec    7
3608 #define SYS_fstat   8
3609 #define SYS_chdir   9
3610 #define SYS_dup    10
3611 #define SYS_getpid 11
3612 #define SYS_sbrk   12
3613 #define SYS_sleep  13
3614 #define SYS_uptime 14
3615 #define SYS_open   15
3616 #define SYS_write  16
3617 #define SYS_mknod  17
3618 #define SYS_unlink 18
3619 #define SYS_link   19
3620 #define SYS_mkdir  20
3621 #define SYS_close  21
3622 #define SYS_printpt 22
3623 
3624 
3625 
3626 
3627 
3628 
3629 
3630 
3631 
3632 
3633 
3634 
3635 
3636 
3637 
3638 
3639 
3640 
3641 
3642 
3643 
3644 
3645 
3646 
3647 
3648 
3649 
3650 #include "types.h"
3651 #include "defs.h"
3652 #include "param.h"
3653 #include "memlayout.h"
3654 #include "mmu.h"
3655 #include "proc.h"
3656 #include "x86.h"
3657 #include "syscall.h"
3658 
3659 
3660 
3661 
3662 
3663 
3664 
3665 
3666 int
3667 fetchint(uint addr, int *ip)
3668 {
3669   struct proc *curproc = myproc();
3670 
3671   if(addr >= curproc->sz || addr+4 > curproc->sz)
3672     return -1;
3673   *ip = *(int*)(addr);
3674   return 0;
3675 }
3676 
3677 
3678 
3679 
3680 int
3681 fetchstr(uint addr, char **pp)
3682 {
3683   char *s, *ep;
3684   struct proc *curproc = myproc();
3685 
3686   if(addr >= curproc->sz)
3687     return -1;
3688   *pp = (char*)addr;
3689   ep = (char*)curproc->sz;
3690   for(s = *pp; s < ep; s++){
3691     if(*s == 0)
3692       return s - *pp;
3693   }
3694   return -1;
3695 }
3696 
3697 
3698 
3699 
3700 
3701 int
3702 argint(int n, int *ip)
3703 {
3704   return fetchint((myproc()->tf->esp) + 4 + 4*n, ip);
3705 }
3706 
3707 
3708 
3709 
3710 int
3711 argptr(int n, char **pp, int size)
3712 {
3713   int i;
3714   struct proc *curproc = myproc();
3715 
3716   if(argint(n, &i) < 0)
3717     return -1;
3718   if(size < 0 || (uint)i >= curproc->sz || (uint)i+size > curproc->sz)
3719     return -1;
3720   *pp = (char*)i;
3721   return 0;
3722 }
3723 
3724 
3725 
3726 
3727 
3728 int
3729 argstr(int n, char **pp)
3730 {
3731   int addr;
3732   if(argint(n, &addr) < 0)
3733     return -1;
3734   return fetchstr(addr, pp);
3735 }
3736 
3737 
3738 
3739 
3740 
3741 
3742 
3743 
3744 
3745 
3746 
3747 
3748 
3749 
3750 extern int sys_chdir(void);
3751 extern int sys_close(void);
3752 extern int sys_dup(void);
3753 extern int sys_exec(void);
3754 extern int sys_exit(void);
3755 extern int sys_fork(void);
3756 extern int sys_fstat(void);
3757 extern int sys_getpid(void);
3758 extern int sys_kill(void);
3759 extern int sys_link(void);
3760 extern int sys_mkdir(void);
3761 extern int sys_mknod(void);
3762 extern int sys_open(void);
3763 extern int sys_pipe(void);
3764 extern int sys_read(void);
3765 extern int sys_sbrk(void);
3766 extern int sys_sleep(void);
3767 extern int sys_unlink(void);
3768 extern int sys_wait(void);
3769 extern int sys_write(void);
3770 extern int sys_uptime(void);
3771 extern int sys_printpt(void);
3772 
3773 static int (*syscalls[])(void) = {
3774 [SYS_fork]    sys_fork,
3775 [SYS_exit]    sys_exit,
3776 [SYS_wait]    sys_wait,
3777 [SYS_pipe]    sys_pipe,
3778 [SYS_read]    sys_read,
3779 [SYS_kill]    sys_kill,
3780 [SYS_exec]    sys_exec,
3781 [SYS_fstat]   sys_fstat,
3782 [SYS_chdir]   sys_chdir,
3783 [SYS_dup]     sys_dup,
3784 [SYS_getpid]  sys_getpid,
3785 [SYS_sbrk]    sys_sbrk,
3786 [SYS_sleep]   sys_sleep,
3787 [SYS_uptime]  sys_uptime,
3788 [SYS_open]    sys_open,
3789 [SYS_write]   sys_write,
3790 [SYS_mknod]   sys_mknod,
3791 [SYS_unlink]  sys_unlink,
3792 [SYS_link]    sys_link,
3793 [SYS_mkdir]   sys_mkdir,
3794 [SYS_close]   sys_close,
3795 [SYS_printpt] sys_printpt,
3796 };
3797 
3798 
3799 
3800 void
3801 syscall(void)
3802 {
3803   int num;
3804   struct proc *curproc = myproc();
3805 
3806   num = curproc->tf->eax;
3807   if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
3808     curproc->tf->eax = syscalls[num]();
3809   } else {
3810     cprintf("%d %s: unknown sys call %d\n",
3811             curproc->pid, curproc->name, num);
3812     curproc->tf->eax = -1;
3813   }
3814 }
3815 
3816 
3817 
3818 
3819 
3820 
3821 
3822 
3823 
3824 
3825 
3826 
3827 
3828 
3829 
3830 
3831 
3832 
3833 
3834 
3835 
3836 
3837 
3838 
3839 
3840 
3841 
3842 
3843 
3844 
3845 
3846 
3847 
3848 
3849 
3850 #include "types.h"
3851 #include "x86.h"
3852 #include "defs.h"
3853 #include "date.h"
3854 #include "param.h"
3855 #include "memlayout.h"
3856 #include "mmu.h"
3857 #include "proc.h"
3858 
3859 int
3860 sys_fork(void)
3861 {
3862   return fork();
3863 }
3864 
3865 int
3866 sys_exit(void)
3867 {
3868   exit();
3869   return 0;  
3870 }
3871 
3872 int
3873 sys_wait(void)
3874 {
3875   return wait();
3876 }
3877 
3878 int
3879 sys_kill(void)
3880 {
3881   int pid;
3882 
3883   if(argint(0, &pid) < 0)
3884     return -1;
3885   return kill(pid);
3886 }
3887 
3888 int
3889 sys_getpid(void)
3890 {
3891   return myproc()->pid;
3892 }
3893 
3894 
3895 
3896 
3897 
3898 
3899 
3900 int
3901 sys_sbrk(void)
3902 {
3903   int addr;
3904   int n;
3905 
3906   if(argint(0, &n) < 0)
3907     return -1;
3908   addr = myproc()->sz;
3909   if(growproc(n) < 0)
3910     return -1;
3911   return addr;
3912 }
3913 
3914 int
3915 sys_sleep(void)
3916 {
3917   int n;
3918   uint ticks0;
3919 
3920   if(argint(0, &n) < 0)
3921     return -1;
3922   acquire(&tickslock);
3923   ticks0 = ticks;
3924   while(ticks - ticks0 < n){
3925     if(myproc()->killed){
3926       release(&tickslock);
3927       return -1;
3928     }
3929     sleep(&ticks, &tickslock);
3930   }
3931   release(&tickslock);
3932   return 0;
3933 }
3934 
3935 
3936 
3937 int
3938 sys_uptime(void)
3939 {
3940   uint xticks;
3941 
3942   acquire(&tickslock);
3943   xticks = ticks;
3944   release(&tickslock);
3945   return xticks;
3946 }
3947 
3948 
3949 
3950 int
3951 sys_printpt(void)
3952 {
3953     int pid;
3954     if (argint(0, &pid) < 0)
3955         return -1;
3956     return printpt(pid);
3957 }
3958 
3959 
3960 
3961 
3962 
3963 
3964 
3965 
3966 
3967 
3968 
3969 
3970 
3971 
3972 
3973 
3974 
3975 
3976 
3977 
3978 
3979 
3980 
3981 
3982 
3983 
3984 
3985 
3986 
3987 
3988 
3989 
3990 
3991 
3992 
3993 
3994 
3995 
3996 
3997 
3998 
3999 
4000 struct buf {
4001   int flags;
4002   uint dev;
4003   uint blockno;
4004   struct sleeplock lock;
4005   uint refcnt;
4006   struct buf *prev; 
4007   struct buf *next;
4008   struct buf *qnext; 
4009   uchar data[BSIZE];
4010 };
4011 #define B_VALID 0x2  
4012 #define B_DIRTY 0x4  
4013 
4014 
4015 
4016 
4017 
4018 
4019 
4020 
4021 
4022 
4023 
4024 
4025 
4026 
4027 
4028 
4029 
4030 
4031 
4032 
4033 
4034 
4035 
4036 
4037 
4038 
4039 
4040 
4041 
4042 
4043 
4044 
4045 
4046 
4047 
4048 
4049 
4050 
4051 struct sleeplock {
4052   uint locked;       
4053   struct spinlock lk; 
4054 
4055   
4056   char *name;        
4057   int pid;           
4058 };
4059 
4060 
4061 
4062 
4063 
4064 
4065 
4066 
4067 
4068 
4069 
4070 
4071 
4072 
4073 
4074 
4075 
4076 
4077 
4078 
4079 
4080 
4081 
4082 
4083 
4084 
4085 
4086 
4087 
4088 
4089 
4090 
4091 
4092 
4093 
4094 
4095 
4096 
4097 
4098 
4099 
4100 #define O_RDONLY  0x000
4101 #define O_WRONLY  0x001
4102 #define O_RDWR    0x002
4103 #define O_CREATE  0x200
4104 
4105 
4106 
4107 
4108 
4109 
4110 
4111 
4112 
4113 
4114 
4115 
4116 
4117 
4118 
4119 
4120 
4121 
4122 
4123 
4124 
4125 
4126 
4127 
4128 
4129 
4130 
4131 
4132 
4133 
4134 
4135 
4136 
4137 
4138 
4139 
4140 
4141 
4142 
4143 
4144 
4145 
4146 
4147 
4148 
4149 
4150 #define T_DIR  1   
4151 #define T_FILE 2   
4152 #define T_DEV  3   
4153 
4154 struct stat {
4155   short type;  
4156   int dev;     
4157   uint ino;    
4158   short nlink; 
4159   uint size;   
4160 };
4161 
4162 
4163 
4164 
4165 
4166 
4167 
4168 
4169 
4170 
4171 
4172 
4173 
4174 
4175 
4176 
4177 
4178 
4179 
4180 
4181 
4182 
4183 
4184 
4185 
4186 
4187 
4188 
4189 
4190 
4191 
4192 
4193 
4194 
4195 
4196 
4197 
4198 
4199 
4200 
4201 
4202 
4203 
4204 #define ROOTINO 1  
4205 #define BSIZE 512  
4206 
4207 
4208 
4209 
4210 
4211 
4212 
4213 struct superblock {
4214   uint size;         
4215   uint nblocks;      
4216   uint ninodes;      
4217   uint nlog;         
4218   uint logstart;     
4219   uint inodestart;   
4220   uint bmapstart;    
4221 };
4222 
4223 #define NDIRECT 12
4224 #define NINDIRECT (BSIZE / sizeof(uint))
4225 #define MAXFILE (NDIRECT + NINDIRECT)
4226 
4227 
4228 struct dinode {
4229   short type;           
4230   short major;          
4231   short minor;          
4232   short nlink;          
4233   uint size;            
4234   uint addrs[NDIRECT+1];   
4235 };
4236 
4237 
4238 
4239 
4240 
4241 
4242 
4243 
4244 
4245 
4246 
4247 
4248 
4249 
4250 
4251 #define IPB           (BSIZE / sizeof(struct dinode))
4252 
4253 
4254 #define IBLOCK(i, sb)     ((i) / IPB + sb.inodestart)
4255 
4256 
4257 #define BPB           (BSIZE*8)
4258 
4259 
4260 #define BBLOCK(b, sb) (b/BPB + sb.bmapstart)
4261 
4262 
4263 #define DIRSIZ 14
4264 
4265 struct dirent {
4266   ushort inum;
4267   char name[DIRSIZ];
4268 };
4269 
4270 
4271 
4272 
4273 
4274 
4275 
4276 
4277 
4278 
4279 
4280 
4281 
4282 
4283 
4284 
4285 
4286 
4287 
4288 
4289 
4290 
4291 
4292 
4293 
4294 
4295 
4296 
4297 
4298 
4299 
4300 struct file {
4301   enum { FD_NONE, FD_PIPE, FD_INODE } type;
4302   int ref; 
4303   char readable;
4304   char writable;
4305   struct pipe *pipe;
4306   struct inode *ip;
4307   uint off;
4308 };
4309 
4310 
4311 
4312 struct inode {
4313   uint dev;           
4314   uint inum;          
4315   int ref;            
4316   struct sleeplock lock; 
4317   int valid;          
4318 
4319   short type;         
4320   short major;
4321   short minor;
4322   short nlink;
4323   uint size;
4324   uint addrs[NDIRECT+1];
4325 };
4326 
4327 
4328 
4329 struct devsw {
4330   int (*read)(struct inode*, char*, int);
4331   int (*write)(struct inode*, char*, int);
4332 };
4333 
4334 extern struct devsw devsw[];
4335 
4336 #define CONSOLE 1
4337 
4338 
4339 
4340 
4341 
4342 
4343 
4344 
4345 
4346 
4347 
4348 
4349 
4350 
4351 
4352 #include "types.h"
4353 #include "defs.h"
4354 #include "param.h"
4355 #include "memlayout.h"
4356 #include "mmu.h"
4357 #include "proc.h"
4358 #include "x86.h"
4359 #include "traps.h"
4360 #include "spinlock.h"
4361 #include "sleeplock.h"
4362 #include "fs.h"
4363 #include "buf.h"
4364 
4365 #define SECTOR_SIZE   512
4366 #define IDE_BSY       0x80
4367 #define IDE_DRDY      0x40
4368 #define IDE_DF        0x20
4369 #define IDE_ERR       0x01
4370 
4371 #define IDE_CMD_READ  0x20
4372 #define IDE_CMD_WRITE 0x30
4373 #define IDE_CMD_RDMUL 0xc4
4374 #define IDE_CMD_WRMUL 0xc5
4375 
4376 #define IDE_DEBUG     1
4377 
4378 
4379 
4380 
4381 
4382 static struct spinlock idelock;
4383 static struct buf *idequeue;
4384 
4385 static int havedisk1;
4386 static void idestart(struct buf*);
4387 
4388 
4389 static int
4390 idewait(int checkerr)
4391 {
4392   int r;
4393 
4394   while(((r = inb(0x1f7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
4395     ;
4396   if(checkerr && (r & (IDE_DF|IDE_ERR)) != 0)
4397     return -1;
4398   return 0;
4399 }
4400 void
4401 ideinit(void)
4402 {
4403   int i;
4404 
4405   initlock(&idelock, "ide");
4406   ioapicenable(IRQ_IDE, ncpu - 1);
4407   idewait(0);
4408 
4409   
4410   outb(0x1f6, 0xe0 | (1<<4));
4411   for(i=0; i<1000; i++){
4412     if(inb(0x1f7) != 0){
4413       havedisk1 = 1;
4414       break;
4415     }
4416   }
4417 
4418   
4419   outb(0x1f6, 0xe0 | (0<<4));
4420 }
4421 
4422 
4423 static void
4424 idestart(struct buf *b)
4425 {
4426   if(b == 0)
4427     panic("idestart");
4428   if(b->blockno >= FSSIZE)
4429     panic("incorrect blockno");
4430   int sector_per_block =  BSIZE/SECTOR_SIZE;
4431   int sector = b->blockno * sector_per_block;
4432   int read_cmd = (sector_per_block == 1) ? IDE_CMD_READ :  IDE_CMD_RDMUL;
4433   int write_cmd = (sector_per_block == 1) ? IDE_CMD_WRITE : IDE_CMD_WRMUL;
4434 
4435   if (sector_per_block > 7) panic("idestart");
4436 
4437   idewait(0);
4438   outb(0x3f6, 0);  
4439   outb(0x1f2, sector_per_block);  
4440   outb(0x1f3, sector & 0xff);
4441   outb(0x1f4, (sector >> 8) & 0xff);
4442   outb(0x1f5, (sector >> 16) & 0xff);
4443   outb(0x1f6, 0xe0 | ((b->dev&1)<<4) | ((sector>>24)&0x0f));
4444   if(b->flags & B_DIRTY){
4445     outb(0x1f7, write_cmd);
4446     outsl(0x1f0, b->data, BSIZE/4);
4447   } else {
4448     outb(0x1f7, read_cmd);
4449   }
4450 }
4451 
4452 
4453 void
4454 ideintr(void)
4455 {
4456   struct buf *b;
4457 
4458   
4459   acquire(&idelock);
4460 
4461   if((b = idequeue) == 0){
4462     release(&idelock);
4463     return;
4464   }
4465   idequeue = b->qnext;
4466 
4467   
4468   if(!(b->flags & B_DIRTY) && idewait(1) >= 0)
4469     insl(0x1f0, b->data, BSIZE/4);
4470 
4471   
4472   b->flags |= B_VALID;
4473   b->flags &= ~B_DIRTY;
4474   wakeup(b);
4475 
4476   
4477   if(idequeue != 0)
4478     idestart(idequeue);
4479 
4480   release(&idelock);
4481 }
4482 
4483 
4484 
4485 
4486 
4487 
4488 
4489 
4490 
4491 
4492 
4493 
4494 
4495 
4496 
4497 
4498 
4499 
4500 
4501 
4502 
4503 void
4504 iderw(struct buf *b)
4505 {
4506   struct buf **pp;
4507 #if IDE_DEBUG
4508   cprintf("b->dev: %x havedisk1: %x\n",b->dev,havedisk1);
4509 #endif
4510   if(!holdingsleep(&b->lock))
4511     panic("iderw: buf not locked");
4512   if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
4513     panic("iderw: nothing to do");
4514   if(b->dev != 0 && !havedisk1)
4515     panic("iderw: ide disk 1 not present");
4516 
4517   acquire(&idelock);  
4518 
4519   
4520   b->qnext = 0;
4521   for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  
4522     ;
4523   *pp = b;
4524 
4525   
4526   if(idequeue == b)
4527     idestart(b);
4528 
4529   
4530   while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
4531     sleep(b, &idelock);
4532   }
4533 
4534 
4535   release(&idelock);
4536 }
4537 
4538 
4539 
4540 
4541 
4542 
4543 
4544 
4545 
4546 
4547 
4548 
4549 
4550 
4551 
4552 
4553 
4554 
4555 
4556 
4557 
4558 
4559 
4560 
4561 
4562 
4563 
4564 
4565 
4566 
4567 
4568 
4569 
4570 #include "types.h"
4571 #include "defs.h"
4572 #include "param.h"
4573 #include "spinlock.h"
4574 #include "sleeplock.h"
4575 #include "fs.h"
4576 #include "buf.h"
4577 
4578 struct {
4579   struct spinlock lock;
4580   struct buf buf[NBUF];
4581 
4582   
4583   
4584   struct buf head;
4585 } bcache;
4586 
4587 void
4588 binit(void)
4589 {
4590   struct buf *b;
4591 
4592   initlock(&bcache.lock, "bcache");
4593 
4594 
4595 
4596 
4597 
4598 
4599 
4600   
4601   bcache.head.prev = &bcache.head;
4602   bcache.head.next = &bcache.head;
4603   for(b = bcache.buf; b < bcache.buf+NBUF; b++){
4604     b->next = bcache.head.next;
4605     b->prev = &bcache.head;
4606     initsleeplock(&b->lock, "buffer");
4607     bcache.head.next->prev = b;
4608     bcache.head.next = b;
4609   }
4610 }
4611 
4612 
4613 
4614 
4615 static struct buf*
4616 bget(uint dev, uint blockno)
4617 {
4618   struct buf *b;
4619 
4620   acquire(&bcache.lock);
4621 
4622   
4623   for(b = bcache.head.next; b != &bcache.head; b = b->next){
4624     if(b->dev == dev && b->blockno == blockno){
4625       b->refcnt++;
4626       release(&bcache.lock);
4627       acquiresleep(&b->lock);
4628       return b;
4629     }
4630   }
4631 
4632   
4633   
4634   
4635   for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
4636     if(b->refcnt == 0 && (b->flags & B_DIRTY) == 0) {
4637       b->dev = dev;
4638       b->blockno = blockno;
4639       b->flags = 0;
4640       b->refcnt = 1;
4641       release(&bcache.lock);
4642       acquiresleep(&b->lock);
4643       return b;
4644     }
4645   }
4646   panic("bget: no buffers");
4647 }
4648 
4649 
4650 
4651 struct buf*
4652 bread(uint dev, uint blockno)
4653 {
4654   struct buf *b;
4655 
4656   b = bget(dev, blockno);
4657   if((b->flags & B_VALID) == 0) {
4658     iderw(b);
4659   }
4660   return b;
4661 }
4662 
4663 
4664 void
4665 bwrite(struct buf *b)
4666 {
4667   if(!holdingsleep(&b->lock))
4668     panic("bwrite");
4669   b->flags |= B_DIRTY;
4670   iderw(b);
4671 }
4672 
4673 
4674 
4675 void
4676 brelse(struct buf *b)
4677 {
4678   if(!holdingsleep(&b->lock))
4679     panic("brelse");
4680 
4681   releasesleep(&b->lock);
4682 
4683   acquire(&bcache.lock);
4684   b->refcnt--;
4685   if (b->refcnt == 0) {
4686     
4687     b->next->prev = b->prev;
4688     b->prev->next = b->next;
4689     b->next = bcache.head.next;
4690     b->prev = &bcache.head;
4691     bcache.head.next->prev = b;
4692     bcache.head.next = b;
4693   }
4694 
4695   release(&bcache.lock);
4696 }
4697 
4698 
4699 
4700 
4701 
4702 
4703 
4704 
4705 
4706 
4707 
4708 
4709 
4710 
4711 
4712 
4713 
4714 
4715 
4716 
4717 
4718 
4719 
4720 
4721 
4722 
4723 
4724 
4725 
4726 
4727 
4728 
4729 
4730 
4731 
4732 
4733 
4734 
4735 
4736 
4737 
4738 
4739 
4740 
4741 
4742 
4743 
4744 
4745 
4746 
4747 
4748 
4749 
4750 
4751 
4752 #include "types.h"
4753 #include "defs.h"
4754 #include "param.h"
4755 #include "x86.h"
4756 #include "memlayout.h"
4757 #include "mmu.h"
4758 #include "proc.h"
4759 #include "spinlock.h"
4760 #include "sleeplock.h"
4761 
4762 void
4763 initsleeplock(struct sleeplock *lk, char *name)
4764 {
4765   initlock(&lk->lk, "sleep lock");
4766   lk->name = name;
4767   lk->locked = 0;
4768   lk->pid = 0;
4769 }
4770 
4771 void
4772 acquiresleep(struct sleeplock *lk)
4773 {
4774   acquire(&lk->lk);
4775   while (lk->locked) {
4776     sleep(lk, &lk->lk);
4777   }
4778   lk->locked = 1;
4779   lk->pid = myproc()->pid;
4780   release(&lk->lk);
4781 }
4782 
4783 void
4784 releasesleep(struct sleeplock *lk)
4785 {
4786   acquire(&lk->lk);
4787   lk->locked = 0;
4788   lk->pid = 0;
4789   wakeup(lk);
4790   release(&lk->lk);
4791 }
4792 
4793 
4794 
4795 
4796 
4797 
4798 
4799 
4800 int
4801 holdingsleep(struct sleeplock *lk)
4802 {
4803   int r;
4804 
4805   acquire(&lk->lk);
4806   r = lk->locked;
4807   release(&lk->lk);
4808   return r;
4809 }
4810 
4811 
4812 
4813 
4814 
4815 
4816 
4817 
4818 
4819 
4820 
4821 
4822 
4823 
4824 
4825 
4826 
4827 
4828 
4829 
4830 
4831 
4832 
4833 
4834 
4835 
4836 
4837 
4838 
4839 
4840 
4841 
4842 
4843 
4844 
4845 
4846 
4847 
4848 
4849 
4850 #include "types.h"
4851 #include "defs.h"
4852 #include "param.h"
4853 #include "spinlock.h"
4854 #include "sleeplock.h"
4855 #include "fs.h"
4856 #include "buf.h"
4857 
4858 
4859 
4860 
4861 
4862 
4863 
4864 
4865 
4866 
4867 
4868 
4869 
4870 
4871 
4872 
4873 
4874 
4875 
4876 
4877 
4878 
4879 
4880 
4881 
4882 
4883 struct logheader {
4884   int n;
4885   int block[LOGSIZE];
4886 };
4887 
4888 struct log {
4889   struct spinlock lock;
4890   int start;
4891   int size;
4892   int outstanding; 
4893   int committing;  
4894   int dev;
4895   struct logheader lh;
4896 };
4897 
4898 
4899 
4900 struct log log;
4901 
4902 static void recover_from_log(void);
4903 static void commit();
4904 
4905 void
4906 initlog(int dev)
4907 {
4908   if (sizeof(struct logheader) >= BSIZE)
4909     panic("initlog: too big logheader");
4910 
4911   struct superblock sb;
4912   initlock(&log.lock, "log");
4913   readsb(dev, &sb);
4914   log.start = sb.logstart;
4915   log.size = sb.nlog;
4916   log.dev = dev;
4917   recover_from_log();
4918 }
4919 
4920 
4921 static void
4922 install_trans(void)
4923 {
4924   int tail;
4925 
4926   for (tail = 0; tail < log.lh.n; tail++) {
4927     struct buf *lbuf = bread(log.dev, log.start+tail+1); 
4928     struct buf *dbuf = bread(log.dev, log.lh.block[tail]); 
4929     memmove(dbuf->data, lbuf->data, BSIZE);  
4930     bwrite(dbuf);  
4931     brelse(lbuf);
4932     brelse(dbuf);
4933   }
4934 }
4935 
4936 
4937 static void
4938 read_head(void)
4939 {
4940   struct buf *buf = bread(log.dev, log.start);
4941   struct logheader *lh = (struct logheader *) (buf->data);
4942   int i;
4943   log.lh.n = lh->n;
4944   for (i = 0; i < log.lh.n; i++) {
4945     log.lh.block[i] = lh->block[i];
4946   }
4947   brelse(buf);
4948 }
4949 
4950 
4951 
4952 
4953 static void
4954 write_head(void)
4955 {
4956   struct buf *buf = bread(log.dev, log.start);
4957   struct logheader *hb = (struct logheader *) (buf->data);
4958   int i;
4959   hb->n = log.lh.n;
4960   for (i = 0; i < log.lh.n; i++) {
4961     hb->block[i] = log.lh.block[i];
4962   }
4963   bwrite(buf);
4964   brelse(buf);
4965 }
4966 
4967 static void
4968 recover_from_log(void)
4969 {
4970   read_head();
4971   install_trans(); 
4972   log.lh.n = 0;
4973   write_head(); 
4974 }
4975 
4976 
4977 void
4978 begin_op(void)
4979 {
4980   acquire(&log.lock);
4981   while(1){
4982     if(log.committing){
4983       sleep(&log, &log.lock);
4984     } else if(log.lh.n + (log.outstanding+1)*MAXOPBLOCKS > LOGSIZE){
4985       
4986       sleep(&log, &log.lock);
4987     } else {
4988       log.outstanding += 1;
4989       release(&log.lock);
4990       break;
4991     }
4992   }
4993 }
4994 
4995 
4996 
4997 
4998 
4999 
5000 
5001 
5002 void
5003 end_op(void)
5004 {
5005   int do_commit = 0;
5006 
5007   acquire(&log.lock);
5008   log.outstanding -= 1;
5009   if(log.committing)
5010     panic("log.committing");
5011   if(log.outstanding == 0){
5012     do_commit = 1;
5013     log.committing = 1;
5014   } else {
5015     
5016     
5017     
5018     wakeup(&log);
5019   }
5020   release(&log.lock);
5021 
5022   if(do_commit){
5023     
5024     
5025     commit();
5026     acquire(&log.lock);
5027     log.committing = 0;
5028     wakeup(&log);
5029     release(&log.lock);
5030   }
5031 }
5032 
5033 
5034 static void
5035 write_log(void)
5036 {
5037   int tail;
5038 
5039   for (tail = 0; tail < log.lh.n; tail++) {
5040     struct buf *to = bread(log.dev, log.start+tail+1); 
5041     struct buf *from = bread(log.dev, log.lh.block[tail]); 
5042     memmove(to->data, from->data, BSIZE);
5043     bwrite(to);  
5044     brelse(from);
5045     brelse(to);
5046   }
5047 }
5048 
5049 
5050 static void
5051 commit()
5052 {
5053   if (log.lh.n > 0) {
5054     write_log();     
5055     write_head();    
5056     install_trans(); 
5057     log.lh.n = 0;
5058     write_head();    
5059   }
5060 }
5061 
5062 
5063 
5064 
5065 
5066 
5067 
5068 
5069 
5070 
5071 void
5072 log_write(struct buf *b)
5073 {
5074   int i;
5075 
5076   if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
5077     panic("too big a transaction");
5078   if (log.outstanding < 1)
5079     panic("log_write outside of trans");
5080 
5081   acquire(&log.lock);
5082   for (i = 0; i < log.lh.n; i++) {
5083     if (log.lh.block[i] == b->blockno)   
5084       break;
5085   }
5086   log.lh.block[i] = b->blockno;
5087   if (i == log.lh.n)
5088     log.lh.n++;
5089   b->flags |= B_DIRTY; 
5090   release(&log.lock);
5091 }
5092 
5093 
5094 
5095 
5096 
5097 
5098 
5099 
5100 
5101 
5102 
5103 
5104 
5105 
5106 
5107 
5108 
5109 
5110 
5111 #include "types.h"
5112 #include "defs.h"
5113 #include "param.h"
5114 #include "stat.h"
5115 #include "mmu.h"
5116 #include "proc.h"
5117 #include "spinlock.h"
5118 #include "sleeplock.h"
5119 #include "fs.h"
5120 #include "buf.h"
5121 #include "file.h"
5122 
5123 #define min(a, b) ((a) < (b) ? (a) : (b))
5124 static void itrunc(struct inode*);
5125 
5126 
5127 struct superblock sb;
5128 
5129 
5130 void
5131 readsb(int dev, struct superblock *sb)
5132 {
5133   struct buf *bp;
5134 
5135   bp = bread(dev, 1);
5136   memmove(sb, bp->data, sizeof(*sb));
5137   brelse(bp);
5138 }
5139 
5140 
5141 
5142 
5143 
5144 
5145 
5146 
5147 
5148 
5149 
5150 
5151 static void
5152 bzero(int dev, int bno)
5153 {
5154   struct buf *bp;
5155 
5156   bp = bread(dev, bno);
5157   memset(bp->data, 0, BSIZE);
5158   log_write(bp);
5159   brelse(bp);
5160 }
5161 
5162 
5163 
5164 
5165 static uint
5166 balloc(uint dev)
5167 {
5168   int b, bi, m;
5169   struct buf *bp;
5170 
5171   bp = 0;
5172   for(b = 0; b < sb.size; b += BPB){
5173     bp = bread(dev, BBLOCK(b, sb));
5174     for(bi = 0; bi < BPB && b + bi < sb.size; bi++){
5175       m = 1 << (bi % 8);
5176       if((bp->data[bi/8] & m) == 0){  
5177         bp->data[bi/8] |= m;  
5178         log_write(bp);
5179         brelse(bp);
5180         bzero(dev, b + bi);
5181         return b + bi;
5182       }
5183     }
5184     brelse(bp);
5185   }
5186   panic("balloc: out of blocks");
5187 }
5188 
5189 
5190 
5191 
5192 
5193 
5194 
5195 
5196 
5197 
5198 
5199 
5200 
5201 static void
5202 bfree(int dev, uint b)
5203 {
5204   struct buf *bp;
5205   int bi, m;
5206 
5207   readsb(dev, &sb);
5208   bp = bread(dev, BBLOCK(b, sb));
5209   bi = b % BPB;
5210   m = 1 << (bi % 8);
5211   if((bp->data[bi/8] & m) == 0)
5212     panic("freeing free block");
5213   bp->data[bi/8] &= ~m;
5214   log_write(bp);
5215   brelse(bp);
5216 }
5217 
5218 
5219 
5220 
5221 
5222 
5223 
5224 
5225 
5226 
5227 
5228 
5229 
5230 
5231 
5232 
5233 
5234 
5235 
5236 
5237 
5238 
5239 
5240 
5241 
5242 
5243 
5244 
5245 
5246 
5247 
5248 
5249 
5250 
5251 
5252 
5253 
5254 
5255 
5256 
5257 
5258 
5259 
5260 
5261 
5262 
5263 
5264 
5265 
5266 
5267 
5268 
5269 
5270 
5271 
5272 
5273 
5274 
5275 
5276 
5277 
5278 
5279 
5280 
5281 
5282 
5283 
5284 
5285 
5286 
5287 struct {
5288   struct spinlock lock;
5289   struct inode inode[NINODE];
5290 } icache;
5291 
5292 void
5293 iinit(int dev)
5294 {
5295   int i = 0;
5296 
5297   initlock(&icache.lock, "icache");
5298   for(i = 0; i < NINODE; i++) {
5299     initsleeplock(&icache.inode[i].lock, "inode");
5300   }
5301 
5302   readsb(dev, &sb);
5303   cprintf("sb: size %d nblocks %d ninodes %d nlog %d logstart %d\
5304  inodestart %d bmap start %d\n", sb.size, sb.nblocks,
5305           sb.ninodes, sb.nlog, sb.logstart, sb.inodestart,
5306           sb.bmapstart);
5307 }
5308 
5309 static struct inode* iget(uint dev, uint inum);
5310 
5311 
5312 
5313 
5314 
5315 
5316 
5317 
5318 
5319 
5320 
5321 
5322 
5323 
5324 
5325 
5326 
5327 
5328 
5329 
5330 
5331 
5332 
5333 
5334 
5335 
5336 
5337 
5338 
5339 
5340 
5341 
5342 
5343 
5344 
5345 
5346 
5347 
5348 
5349 
5350 
5351 
5352 
5353 struct inode*
5354 ialloc(uint dev, short type)
5355 {
5356   int inum;
5357   struct buf *bp;
5358   struct dinode *dip;
5359 
5360   for(inum = 1; inum < sb.ninodes; inum++){
5361     bp = bread(dev, IBLOCK(inum, sb));
5362     dip = (struct dinode*)bp->data + inum%IPB;
5363     if(dip->type == 0){  
5364       memset(dip, 0, sizeof(*dip));
5365       dip->type = type;
5366       log_write(bp);   
5367       brelse(bp);
5368       return iget(dev, inum);
5369     }
5370     brelse(bp);
5371   }
5372   panic("ialloc: no inodes");
5373 }
5374 
5375 
5376 
5377 
5378 
5379 void
5380 iupdate(struct inode *ip)
5381 {
5382   struct buf *bp;
5383   struct dinode *dip;
5384 
5385   bp = bread(ip->dev, IBLOCK(ip->inum, sb));
5386   dip = (struct dinode*)bp->data + ip->inum%IPB;
5387   dip->type = ip->type;
5388   dip->major = ip->major;
5389   dip->minor = ip->minor;
5390   dip->nlink = ip->nlink;
5391   dip->size = ip->size;
5392   memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
5393   log_write(bp);
5394   brelse(bp);
5395 }
5396 
5397 
5398 
5399 
5400 
5401 
5402 
5403 static struct inode*
5404 iget(uint dev, uint inum)
5405 {
5406   struct inode *ip, *empty;
5407 
5408   acquire(&icache.lock);
5409 
5410   
5411   empty = 0;
5412   for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
5413     if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
5414       ip->ref++;
5415       release(&icache.lock);
5416       return ip;
5417     }
5418     if(empty == 0 && ip->ref == 0)    
5419       empty = ip;
5420   }
5421 
5422   
5423   if(empty == 0)
5424     panic("iget: no inodes");
5425 
5426   ip = empty;
5427   ip->dev = dev;
5428   ip->inum = inum;
5429   ip->ref = 1;
5430   ip->valid = 0;
5431   release(&icache.lock);
5432 
5433   return ip;
5434 }
5435 
5436 
5437 
5438 struct inode*
5439 idup(struct inode *ip)
5440 {
5441   acquire(&icache.lock);
5442   ip->ref++;
5443   release(&icache.lock);
5444   return ip;
5445 }
5446 
5447 
5448 
5449 
5450 
5451 
5452 void
5453 ilock(struct inode *ip)
5454 {
5455   struct buf *bp;
5456   struct dinode *dip;
5457 
5458   if(ip == 0 || ip->ref < 1)
5459     panic("ilock");
5460 
5461   acquiresleep(&ip->lock);
5462 
5463   if(ip->valid == 0){
5464     bp = bread(ip->dev, IBLOCK(ip->inum, sb));
5465     dip = (struct dinode*)bp->data + ip->inum%IPB;
5466     ip->type = dip->type;
5467     ip->major = dip->major;
5468     ip->minor = dip->minor;
5469     ip->nlink = dip->nlink;
5470     ip->size = dip->size;
5471     memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
5472     brelse(bp);
5473     ip->valid = 1;
5474     if(ip->type == 0)
5475       panic("ilock: no type");
5476   }
5477 }
5478 
5479 
5480 void
5481 iunlock(struct inode *ip)
5482 {
5483   if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
5484     panic("iunlock");
5485 
5486   releasesleep(&ip->lock);
5487 }
5488 
5489 
5490 
5491 
5492 
5493 
5494 
5495 
5496 
5497 
5498 
5499 
5500 
5501 
5502 
5503 
5504 
5505 
5506 
5507 void
5508 iput(struct inode *ip)
5509 {
5510   acquiresleep(&ip->lock);
5511   if(ip->valid && ip->nlink == 0){
5512     acquire(&icache.lock);
5513     int r = ip->ref;
5514     release(&icache.lock);
5515     if(r == 1){
5516       
5517       itrunc(ip);
5518       ip->type = 0;
5519       iupdate(ip);
5520       ip->valid = 0;
5521     }
5522   }
5523   releasesleep(&ip->lock);
5524 
5525   acquire(&icache.lock);
5526   ip->ref--;
5527   release(&icache.lock);
5528 }
5529 
5530 
5531 void
5532 iunlockput(struct inode *ip)
5533 {
5534   iunlock(ip);
5535   iput(ip);
5536 }
5537 
5538 
5539 
5540 
5541 
5542 
5543 
5544 
5545 
5546 
5547 
5548 
5549 
5550 
5551 
5552 
5553 
5554 
5555 
5556 
5557 
5558 
5559 static uint
5560 bmap(struct inode *ip, uint bn)
5561 {
5562   uint addr, *a;
5563   struct buf *bp;
5564 
5565   if(bn < NDIRECT){
5566     if((addr = ip->addrs[bn]) == 0)
5567       ip->addrs[bn] = addr = balloc(ip->dev);
5568     return addr;
5569   }
5570   bn -= NDIRECT;
5571 
5572   if(bn < NINDIRECT){
5573     
5574     if((addr = ip->addrs[NDIRECT]) == 0)
5575       ip->addrs[NDIRECT] = addr = balloc(ip->dev);
5576     bp = bread(ip->dev, addr);
5577     a = (uint*)bp->data;
5578     if((addr = a[bn]) == 0){
5579       a[bn] = addr = balloc(ip->dev);
5580       log_write(bp);
5581     }
5582     brelse(bp);
5583     return addr;
5584   }
5585 
5586   panic("bmap: out of range");
5587 }
5588 
5589 
5590 
5591 
5592 
5593 
5594 
5595 
5596 
5597 
5598 
5599 
5600 
5601 
5602 
5603 
5604 
5605 static void
5606 itrunc(struct inode *ip)
5607 {
5608   int i, j;
5609   struct buf *bp;
5610   uint *a;
5611 
5612   for(i = 0; i < NDIRECT; i++){
5613     if(ip->addrs[i]){
5614       bfree(ip->dev, ip->addrs[i]);
5615       ip->addrs[i] = 0;
5616     }
5617   }
5618 
5619   if(ip->addrs[NDIRECT]){
5620     bp = bread(ip->dev, ip->addrs[NDIRECT]);
5621     a = (uint*)bp->data;
5622     for(j = 0; j < NINDIRECT; j++){
5623       if(a[j])
5624         bfree(ip->dev, a[j]);
5625     }
5626     brelse(bp);
5627     bfree(ip->dev, ip->addrs[NDIRECT]);
5628     ip->addrs[NDIRECT] = 0;
5629   }
5630 
5631   ip->size = 0;
5632   iupdate(ip);
5633 }
5634 
5635 
5636 
5637 void
5638 stati(struct inode *ip, struct stat *st)
5639 {
5640   st->dev = ip->dev;
5641   st->ino = ip->inum;
5642   st->type = ip->type;
5643   st->nlink = ip->nlink;
5644   st->size = ip->size;
5645 }
5646 
5647 
5648 
5649 
5650 
5651 
5652 int
5653 readi(struct inode *ip, char *dst, uint off, uint n)
5654 {
5655   uint tot, m;
5656   struct buf *bp;
5657 
5658   if(ip->type == T_DEV){
5659     if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
5660       return -1;
5661     return devsw[ip->major].read(ip, dst, n);
5662   }
5663 
5664   if(off > ip->size || off + n < off)
5665     return -1;
5666   if(off + n > ip->size)
5667     n = ip->size - off;
5668 
5669   for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
5670     bp = bread(ip->dev, bmap(ip, off/BSIZE));
5671     m = min(n - tot, BSIZE - off%BSIZE);
5672     memmove(dst, bp->data + off%BSIZE, m);
5673     brelse(bp);
5674   }
5675   return n;
5676 }
5677 
5678 
5679 
5680 
5681 
5682 
5683 
5684 
5685 
5686 
5687 
5688 
5689 
5690 
5691 
5692 
5693 
5694 
5695 
5696 
5697 
5698 
5699 
5700 
5701 
5702 int
5703 writei(struct inode *ip, char *src, uint off, uint n)
5704 {
5705   uint tot, m;
5706   struct buf *bp;
5707 
5708   if(ip->type == T_DEV){
5709     if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
5710       return -1;
5711     return devsw[ip->major].write(ip, src, n);
5712   }
5713 
5714   if(off > ip->size || off + n < off)
5715     return -1;
5716   if(off + n > MAXFILE*BSIZE)
5717     return -1;
5718 
5719   for(tot=0; tot<n; tot+=m, off+=m, src+=m){
5720     bp = bread(ip->dev, bmap(ip, off/BSIZE));
5721     m = min(n - tot, BSIZE - off%BSIZE);
5722     memmove(bp->data + off%BSIZE, src, m);
5723     log_write(bp);
5724     brelse(bp);
5725   }
5726 
5727   if(n > 0 && off > ip->size){
5728     ip->size = off;
5729     iupdate(ip);
5730   }
5731   return n;
5732 }
5733 
5734 
5735 
5736 
5737 
5738 
5739 
5740 
5741 
5742 
5743 
5744 
5745 
5746 
5747 
5748 
5749 
5750 
5751 
5752 int
5753 namecmp(const char *s, const char *t)
5754 {
5755   return strncmp(s, t, DIRSIZ);
5756 }
5757 
5758 
5759 
5760 struct inode*
5761 dirlookup(struct inode *dp, char *name, uint *poff)
5762 {
5763   uint off, inum;
5764   struct dirent de;
5765 
5766   if(dp->type != T_DIR)
5767     panic("dirlookup not DIR");
5768 
5769   for(off = 0; off < dp->size; off += sizeof(de)){
5770     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
5771       panic("dirlookup read");
5772     if(de.inum == 0)
5773       continue;
5774     if(namecmp(name, de.name) == 0){
5775       
5776       if(poff)
5777         *poff = off;
5778       inum = de.inum;
5779       return iget(dp->dev, inum);
5780     }
5781   }
5782 
5783   return 0;
5784 }
5785 
5786 
5787 
5788 
5789 
5790 
5791 
5792 
5793 
5794 
5795 
5796 
5797 
5798 
5799 
5800 
5801 int
5802 dirlink(struct inode *dp, char *name, uint inum)
5803 {
5804   int off;
5805   struct dirent de;
5806   struct inode *ip;
5807 
5808   
5809   if((ip = dirlookup(dp, name, 0)) != 0){
5810     iput(ip);
5811     return -1;
5812   }
5813 
5814   
5815   for(off = 0; off < dp->size; off += sizeof(de)){
5816     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
5817       panic("dirlink read");
5818     if(de.inum == 0)
5819       break;
5820   }
5821 
5822   strncpy(de.name, name, DIRSIZ);
5823   de.inum = inum;
5824   if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
5825     panic("dirlink");
5826 
5827   return 0;
5828 }
5829 
5830 
5831 
5832 
5833 
5834 
5835 
5836 
5837 
5838 
5839 
5840 
5841 
5842 
5843 
5844 
5845 
5846 
5847 
5848 
5849 
5850 
5851 
5852 
5853 
5854 
5855 
5856 
5857 
5858 
5859 
5860 
5861 
5862 
5863 
5864 static char*
5865 skipelem(char *path, char *name)
5866 {
5867   char *s;
5868   int len;
5869 
5870   while(*path == '/')
5871     path++;
5872   if(*path == 0)
5873     return 0;
5874   s = path;
5875   while(*path != '/' && *path != 0)
5876     path++;
5877   len = path - s;
5878   if(len >= DIRSIZ)
5879     memmove(name, s, DIRSIZ);
5880   else {
5881     memmove(name, s, len);
5882     name[len] = 0;
5883   }
5884   while(*path == '/')
5885     path++;
5886   return path;
5887 }
5888 
5889 
5890 
5891 
5892 
5893 
5894 
5895 
5896 
5897 
5898 
5899 
5900 
5901 
5902 
5903 
5904 static struct inode*
5905 namex(char *path, int nameiparent, char *name)
5906 {
5907   struct inode *ip, *next;
5908 
5909   if(*path == '/')
5910     ip = iget(ROOTDEV, ROOTINO);
5911   else
5912     ip = idup(myproc()->cwd);
5913 
5914   while((path = skipelem(path, name)) != 0){
5915     ilock(ip);
5916     if(ip->type != T_DIR){
5917       iunlockput(ip);
5918       return 0;
5919     }
5920     if(nameiparent && *path == '\0'){
5921       
5922       iunlock(ip);
5923       return ip;
5924     }
5925     if((next = dirlookup(ip, name, 0)) == 0){
5926       iunlockput(ip);
5927       return 0;
5928     }
5929     iunlockput(ip);
5930     ip = next;
5931   }
5932   if(nameiparent){
5933     iput(ip);
5934     return 0;
5935   }
5936   return ip;
5937 }
5938 
5939 struct inode*
5940 namei(char *path)
5941 {
5942   char name[DIRSIZ];
5943   return namex(path, 0, name);
5944 }
5945 
5946 
5947 
5948 
5949 
5950 struct inode*
5951 nameiparent(char *path, char *name)
5952 {
5953   return namex(path, 1, name);
5954 }
5955 
5956 
5957 
5958 
5959 
5960 
5961 
5962 
5963 
5964 
5965 
5966 
5967 
5968 
5969 
5970 
5971 
5972 
5973 
5974 
5975 
5976 
5977 
5978 
5979 
5980 
5981 
5982 
5983 
5984 
5985 
5986 
5987 
5988 
5989 
5990 
5991 
5992 
5993 
5994 
5995 
5996 
5997 
5998 
5999 
6000 
6001 
6002 
6003 
6004 #include "types.h"
6005 #include "defs.h"
6006 #include "param.h"
6007 #include "fs.h"
6008 #include "spinlock.h"
6009 #include "sleeplock.h"
6010 #include "file.h"
6011 
6012 struct devsw devsw[NDEV];
6013 struct {
6014   struct spinlock lock;
6015   struct file file[NFILE];
6016 } ftable;
6017 
6018 void
6019 fileinit(void)
6020 {
6021   initlock(&ftable.lock, "ftable");
6022 }
6023 
6024 
6025 struct file*
6026 filealloc(void)
6027 {
6028   struct file *f;
6029 
6030   acquire(&ftable.lock);
6031   for(f = ftable.file; f < ftable.file + NFILE; f++){
6032     if(f->ref == 0){
6033       f->ref = 1;
6034       release(&ftable.lock);
6035       return f;
6036     }
6037   }
6038   release(&ftable.lock);
6039   return 0;
6040 }
6041 
6042 
6043 
6044 
6045 
6046 
6047 
6048 
6049 
6050 
6051 struct file*
6052 filedup(struct file *f)
6053 {
6054   acquire(&ftable.lock);
6055   if(f->ref < 1)
6056     panic("filedup");
6057   f->ref++;
6058   release(&ftable.lock);
6059   return f;
6060 }
6061 
6062 
6063 void
6064 fileclose(struct file *f)
6065 {
6066   struct file ff;
6067 
6068   acquire(&ftable.lock);
6069   if(f->ref < 1)
6070     panic("fileclose");
6071   if(--f->ref > 0){
6072     release(&ftable.lock);
6073     return;
6074   }
6075   ff = *f;
6076   f->ref = 0;
6077   f->type = FD_NONE;
6078   release(&ftable.lock);
6079 
6080   if(ff.type == FD_PIPE)
6081     pipeclose(ff.pipe, ff.writable);
6082   else if(ff.type == FD_INODE){
6083     begin_op();
6084     iput(ff.ip);
6085     end_op();
6086   }
6087 }
6088 
6089 
6090 
6091 
6092 
6093 
6094 
6095 
6096 
6097 
6098 
6099 
6100 
6101 int
6102 filestat(struct file *f, struct stat *st)
6103 {
6104   if(f->type == FD_INODE){
6105     ilock(f->ip);
6106     stati(f->ip, st);
6107     iunlock(f->ip);
6108     return 0;
6109   }
6110   return -1;
6111 }
6112 
6113 
6114 int
6115 fileread(struct file *f, char *addr, int n)
6116 {
6117   int r;
6118 
6119   if(f->readable == 0)
6120     return -1;
6121   if(f->type == FD_PIPE)
6122     return piperead(f->pipe, addr, n);
6123   if(f->type == FD_INODE){
6124     ilock(f->ip);
6125     if((r = readi(f->ip, addr, f->off, n)) > 0)
6126       f->off += r;
6127     iunlock(f->ip);
6128     return r;
6129   }
6130   panic("fileread");
6131 }
6132 
6133 
6134 
6135 
6136 
6137 
6138 
6139 
6140 
6141 
6142 
6143 
6144 
6145 
6146 
6147 
6148 
6149 
6150 
6151 int
6152 filewrite(struct file *f, char *addr, int n)
6153 {
6154   int r;
6155 
6156   if(f->writable == 0)
6157     return -1;
6158   if(f->type == FD_PIPE)
6159     return pipewrite(f->pipe, addr, n);
6160   if(f->type == FD_INODE){
6161     
6162     
6163     
6164     
6165     
6166     
6167     int max = ((MAXOPBLOCKS-1-1-2) / 2) * 512;
6168     int i = 0;
6169     while(i < n){
6170       int n1 = n - i;
6171       if(n1 > max)
6172         n1 = max;
6173 
6174       begin_op();
6175       ilock(f->ip);
6176       if ((r = writei(f->ip, addr + i, f->off, n1)) > 0)
6177         f->off += r;
6178       iunlock(f->ip);
6179       end_op();
6180 
6181       if(r < 0)
6182         break;
6183       if(r != n1)
6184         panic("short filewrite");
6185       i += r;
6186     }
6187     return i == n ? n : -1;
6188   }
6189   panic("filewrite");
6190 }
6191 
6192 
6193 
6194 
6195 
6196 
6197 
6198 
6199 
6200 
6201 
6202 
6203 
6204 
6205 
6206 #include "types.h"
6207 #include "defs.h"
6208 #include "param.h"
6209 #include "stat.h"
6210 #include "mmu.h"
6211 #include "proc.h"
6212 #include "fs.h"
6213 #include "spinlock.h"
6214 #include "sleeplock.h"
6215 #include "file.h"
6216 #include "fcntl.h"
6217 
6218 
6219 
6220 static int
6221 argfd(int n, int *pfd, struct file **pf)
6222 {
6223   int fd;
6224   struct file *f;
6225 
6226   if(argint(n, &fd) < 0)
6227     return -1;
6228   if(fd < 0 || fd >= NOFILE || (f=myproc()->ofile[fd]) == 0)
6229     return -1;
6230   if(pfd)
6231     *pfd = fd;
6232   if(pf)
6233     *pf = f;
6234   return 0;
6235 }
6236 
6237 
6238 
6239 
6240 
6241 
6242 
6243 
6244 
6245 
6246 
6247 
6248 
6249 
6250 
6251 
6252 static int
6253 fdalloc(struct file *f)
6254 {
6255   int fd;
6256   struct proc *curproc = myproc();
6257 
6258   for(fd = 0; fd < NOFILE; fd++){
6259     if(curproc->ofile[fd] == 0){
6260       curproc->ofile[fd] = f;
6261       return fd;
6262     }
6263   }
6264   return -1;
6265 }
6266 
6267 int
6268 sys_dup(void)
6269 {
6270   struct file *f;
6271   int fd;
6272 
6273   if(argfd(0, 0, &f) < 0)
6274     return -1;
6275   if((fd=fdalloc(f)) < 0)
6276     return -1;
6277   filedup(f);
6278   return fd;
6279 }
6280 
6281 int
6282 sys_read(void)
6283 {
6284   struct file *f;
6285   int n;
6286   char *p;
6287 
6288   if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
6289     return -1;
6290   return fileread(f, p, n);
6291 }
6292 
6293 
6294 
6295 
6296 
6297 
6298 
6299 
6300 int
6301 sys_write(void)
6302 {
6303   struct file *f;
6304   int n;
6305   char *p;
6306 
6307   if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
6308     return -1;
6309   return filewrite(f, p, n);
6310 }
6311 
6312 int
6313 sys_close(void)
6314 {
6315   int fd;
6316   struct file *f;
6317 
6318   if(argfd(0, &fd, &f) < 0)
6319     return -1;
6320   myproc()->ofile[fd] = 0;
6321   fileclose(f);
6322   return 0;
6323 }
6324 
6325 int
6326 sys_fstat(void)
6327 {
6328   struct file *f;
6329   struct stat *st;
6330 
6331   if(argfd(0, 0, &f) < 0 || argptr(1, (void*)&st, sizeof(*st)) < 0)
6332     return -1;
6333   return filestat(f, st);
6334 }
6335 
6336 
6337 
6338 
6339 
6340 
6341 
6342 
6343 
6344 
6345 
6346 
6347 
6348 
6349 
6350 
6351 int
6352 sys_link(void)
6353 {
6354   char name[DIRSIZ], *new, *old;
6355   struct inode *dp, *ip;
6356 
6357   if(argstr(0, &old) < 0 || argstr(1, &new) < 0)
6358     return -1;
6359 
6360   begin_op();
6361   if((ip = namei(old)) == 0){
6362     end_op();
6363     return -1;
6364   }
6365 
6366   ilock(ip);
6367   if(ip->type == T_DIR){
6368     iunlockput(ip);
6369     end_op();
6370     return -1;
6371   }
6372 
6373   ip->nlink++;
6374   iupdate(ip);
6375   iunlock(ip);
6376 
6377   if((dp = nameiparent(new, name)) == 0)
6378     goto bad;
6379   ilock(dp);
6380   if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
6381     iunlockput(dp);
6382     goto bad;
6383   }
6384   iunlockput(dp);
6385   iput(ip);
6386 
6387   end_op();
6388 
6389   return 0;
6390 
6391 bad:
6392   ilock(ip);
6393   ip->nlink--;
6394   iupdate(ip);
6395   iunlockput(ip);
6396   end_op();
6397   return -1;
6398 }
6399 
6400 
6401 static int
6402 isdirempty(struct inode *dp)
6403 {
6404   int off;
6405   struct dirent de;
6406 
6407   for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
6408     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
6409       panic("isdirempty: readi");
6410     if(de.inum != 0)
6411       return 0;
6412   }
6413   return 1;
6414 }
6415 
6416 
6417 
6418 
6419 
6420 
6421 
6422 
6423 
6424 
6425 
6426 
6427 
6428 
6429 
6430 
6431 
6432 
6433 
6434 
6435 
6436 
6437 
6438 
6439 
6440 
6441 
6442 
6443 
6444 
6445 
6446 
6447 
6448 
6449 
6450 int
6451 sys_unlink(void)
6452 {
6453   struct inode *ip, *dp;
6454   struct dirent de;
6455   char name[DIRSIZ], *path;
6456   uint off;
6457 
6458   if(argstr(0, &path) < 0)
6459     return -1;
6460 
6461   begin_op();
6462   if((dp = nameiparent(path, name)) == 0){
6463     end_op();
6464     return -1;
6465   }
6466 
6467   ilock(dp);
6468 
6469   
6470   if(namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
6471     goto bad;
6472 
6473   if((ip = dirlookup(dp, name, &off)) == 0)
6474     goto bad;
6475   ilock(ip);
6476 
6477   if(ip->nlink < 1)
6478     panic("unlink: nlink < 1");
6479   if(ip->type == T_DIR && !isdirempty(ip)){
6480     iunlockput(ip);
6481     goto bad;
6482   }
6483 
6484   memset(&de, 0, sizeof(de));
6485   if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
6486     panic("unlink: writei");
6487   if(ip->type == T_DIR){
6488     dp->nlink--;
6489     iupdate(dp);
6490   }
6491   iunlockput(dp);
6492 
6493   ip->nlink--;
6494   iupdate(ip);
6495   iunlockput(ip);
6496 
6497   end_op();
6498 
6499   return 0;
6500 bad:
6501   iunlockput(dp);
6502   end_op();
6503   return -1;
6504 }
6505 
6506 static struct inode*
6507 create(char *path, short type, short major, short minor)
6508 {
6509   uint off;
6510   struct inode *ip, *dp;
6511   char name[DIRSIZ];
6512 
6513   if((dp = nameiparent(path, name)) == 0)
6514     return 0;
6515   ilock(dp);
6516 
6517   if((ip = dirlookup(dp, name, &off)) != 0){
6518     iunlockput(dp);
6519     ilock(ip);
6520     if(type == T_FILE && ip->type == T_FILE)
6521       return ip;
6522     iunlockput(ip);
6523     return 0;
6524   }
6525 
6526   if((ip = ialloc(dp->dev, type)) == 0)
6527     panic("create: ialloc");
6528 
6529   ilock(ip);
6530   ip->major = major;
6531   ip->minor = minor;
6532   ip->nlink = 1;
6533   iupdate(ip);
6534 
6535   if(type == T_DIR){  
6536     dp->nlink++;  
6537     iupdate(dp);
6538     
6539     if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
6540       panic("create dots");
6541   }
6542 
6543   if(dirlink(dp, name, ip->inum) < 0)
6544     panic("create: dirlink");
6545 
6546   iunlockput(dp);
6547 
6548   return ip;
6549 }
6550 int
6551 sys_open(void)
6552 {
6553   char *path;
6554   int fd, omode;
6555   struct file *f;
6556   struct inode *ip;
6557 
6558   if(argstr(0, &path) < 0 || argint(1, &omode) < 0)
6559     return -1;
6560 
6561   begin_op();
6562 
6563   if(omode & O_CREATE){
6564     ip = create(path, T_FILE, 0, 0);
6565     if(ip == 0){
6566       end_op();
6567       return -1;
6568     }
6569   } else {
6570     if((ip = namei(path)) == 0){
6571       end_op();
6572       return -1;
6573     }
6574     ilock(ip);
6575     if(ip->type == T_DIR && omode != O_RDONLY){
6576       iunlockput(ip);
6577       end_op();
6578       return -1;
6579     }
6580   }
6581 
6582   if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){
6583     if(f)
6584       fileclose(f);
6585     iunlockput(ip);
6586     end_op();
6587     return -1;
6588   }
6589   iunlock(ip);
6590   end_op();
6591 
6592   f->type = FD_INODE;
6593   f->ip = ip;
6594   f->off = 0;
6595   f->readable = !(omode & O_WRONLY);
6596   f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
6597   return fd;
6598 }
6599 
6600 int
6601 sys_mkdir(void)
6602 {
6603   char *path;
6604   struct inode *ip;
6605 
6606   begin_op();
6607   if(argstr(0, &path) < 0 || (ip = create(path, T_DIR, 0, 0)) == 0){
6608     end_op();
6609     return -1;
6610   }
6611   iunlockput(ip);
6612   end_op();
6613   return 0;
6614 }
6615 
6616 int
6617 sys_mknod(void)
6618 {
6619   struct inode *ip;
6620   char *path;
6621   int major, minor;
6622 
6623   begin_op();
6624   if((argstr(0, &path)) < 0 ||
6625      argint(1, &major) < 0 ||
6626      argint(2, &minor) < 0 ||
6627      (ip = create(path, T_DEV, major, minor)) == 0){
6628     end_op();
6629     return -1;
6630   }
6631   iunlockput(ip);
6632   end_op();
6633   return 0;
6634 }
6635 
6636 
6637 
6638 
6639 
6640 
6641 
6642 
6643 
6644 
6645 
6646 
6647 
6648 
6649 
6650 int
6651 sys_chdir(void)
6652 {
6653   char *path;
6654   struct inode *ip;
6655   struct proc *curproc = myproc();
6656 
6657   begin_op();
6658   if(argstr(0, &path) < 0 || (ip = namei(path)) == 0){
6659     end_op();
6660     return -1;
6661   }
6662   ilock(ip);
6663   if(ip->type != T_DIR){
6664     iunlockput(ip);
6665     end_op();
6666     return -1;
6667   }
6668   iunlock(ip);
6669   iput(curproc->cwd);
6670   end_op();
6671   curproc->cwd = ip;
6672   return 0;
6673 }
6674 
6675 int
6676 sys_exec(void)
6677 {
6678   char *path, *argv[MAXARG];
6679   int i;
6680   uint uargv, uarg;
6681 
6682   if(argstr(0, &path) < 0 || argint(1, (int*)&uargv) < 0){
6683     return -1;
6684   }
6685   memset(argv, 0, sizeof(argv));
6686   for(i=0;; i++){
6687     if(i >= NELEM(argv))
6688       return -1;
6689     if(fetchint(uargv+4*i, (int*)&uarg) < 0)
6690       return -1;
6691     if(uarg == 0){
6692       argv[i] = 0;
6693       break;
6694     }
6695     if(fetchstr(uarg, &argv[i]) < 0)
6696       return -1;
6697   }
6698   return exec(path, argv);
6699 }
6700 int
6701 sys_pipe(void)
6702 {
6703   int *fd;
6704   struct file *rf, *wf;
6705   int fd0, fd1;
6706 
6707   if(argptr(0, (void*)&fd, 2*sizeof(fd[0])) < 0)
6708     return -1;
6709   if(pipealloc(&rf, &wf) < 0)
6710     return -1;
6711   fd0 = -1;
6712   if((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0){
6713     if(fd0 >= 0)
6714       myproc()->ofile[fd0] = 0;
6715     fileclose(rf);
6716     fileclose(wf);
6717     return -1;
6718   }
6719   fd[0] = fd0;
6720   fd[1] = fd1;
6721   return 0;
6722 }
6723 
6724 
6725 
6726 
6727 
6728 
6729 
6730 
6731 
6732 
6733 
6734 
6735 
6736 
6737 
6738 
6739 
6740 
6741 
6742 
6743 
6744 
6745 
6746 
6747 
6748 
6749 
6750 #include "types.h"
6751 #include "param.h"
6752 #include "memlayout.h"
6753 #include "mmu.h"
6754 #include "proc.h"
6755 #include "defs.h"
6756 #include "x86.h"
6757 #include "elf.h"
6758 
6759 int
6760 exec(char *path, char **argv)
6761 {
6762   char *s, *last;
6763   int i, off;
6764   uint argc, sz, sp, ustack[3+MAXARG+1];
6765   struct elfhdr elf;
6766   struct inode *ip;
6767   struct proghdr ph;
6768   pde_t *pgdir, *oldpgdir;
6769   struct proc *curproc = myproc();
6770 
6771   begin_op();
6772 
6773   if((ip = namei(path)) == 0){
6774     end_op();
6775     cprintf("exec: fail\n");
6776     return -1;
6777   }
6778   ilock(ip);
6779   pgdir = 0;
6780 
6781   
6782   if(readi(ip, (char*)&elf, 0, sizeof(elf)) != sizeof(elf))
6783     goto bad;
6784   if(elf.magic != ELF_MAGIC)
6785     goto bad;
6786 
6787   if((pgdir = setupkvm()) == 0)
6788     goto bad;
6789 
6790   
6791   sz = 0;
6792   for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
6793     if(readi(ip, (char*)&ph, off, sizeof(ph)) != sizeof(ph))
6794       goto bad;
6795     if(ph.type != ELF_PROG_LOAD)
6796       continue;
6797     if(ph.memsz < ph.filesz)
6798       goto bad;
6799     if(ph.vaddr + ph.memsz < ph.vaddr)
6800       goto bad;
6801     if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
6802       goto bad;
6803     if(ph.vaddr % PGSIZE != 0)
6804       goto bad;
6805     if(loaduvm(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz) < 0)
6806       goto bad;
6807   }
6808   iunlockput(ip);
6809   end_op();
6810   ip = 0;
6811 
6812   
6813   
6814 /*   sz = PGROUNDUP(sz);
6815   cprintf(" after PGROUNDUP sz = %d \n", sz);
6816   if((sz = allocuvm(pgdir, sz, sz + 2*PGSIZE)) == 0)
6817     goto bad;
6818   cprintf(" after allocuvm sz = %d \n", sz);
6819   clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
6820   sp = sz; */
6821 
6822     
6823   
6824   sz = PGROUNDDOWN(sz) + PGSIZE;
6825   sp = KERNBASE - 1;
6826   if((allocuvm(pgdir, sp - PGSIZE, sp)) == 0)
6827     goto bad;
6828   curproc->stack_size = PGSIZE;
6829 
6830   
6831   for(argc = 0; argv[argc]; argc++) {
6832     if(argc >= MAXARG)
6833       goto bad;
6834     sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
6835     if(copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
6836       goto bad;
6837     ustack[3+argc] = sp;
6838   }
6839   ustack[3+argc] = 0;
6840 
6841   ustack[0] = 0xffffffff;  
6842   ustack[1] = argc;
6843   ustack[2] = sp - (argc+1)*4;  
6844 
6845   sp -= (3+argc+1) * 4;
6846   if(copyout(pgdir, sp, ustack, (3+argc+1)*4) < 0)
6847     goto bad;
6848 
6849 
6850   
6851   for(last=s=path; *s; s++)
6852     if(*s == '/')
6853       last = s+1;
6854   safestrcpy(curproc->name, last, sizeof(curproc->name));
6855 
6856   
6857   oldpgdir = curproc->pgdir;
6858   curproc->pgdir = pgdir;
6859   curproc->sz = sz;
6860   curproc->tf->eip = elf.entry;  
6861   curproc->tf->esp = sp;
6862   switchuvm(curproc);
6863   freevm(oldpgdir);
6864   return 0;
6865 
6866  bad:
6867   if(pgdir)
6868     freevm(pgdir);
6869   if(ip){
6870     iunlockput(ip);
6871     end_op();
6872   }
6873   return -1;
6874 }
6875 
6876 
6877 
6878 
6879 
6880 
6881 
6882 
6883 
6884 
6885 
6886 
6887 
6888 
6889 
6890 
6891 
6892 
6893 
6894 
6895 
6896 
6897 
6898 
6899 
6900 #include "types.h"
6901 #include "defs.h"
6902 #include "param.h"
6903 #include "mmu.h"
6904 #include "proc.h"
6905 #include "fs.h"
6906 #include "spinlock.h"
6907 #include "sleeplock.h"
6908 #include "file.h"
6909 
6910 #define PIPESIZE 512
6911 
6912 struct pipe {
6913   struct spinlock lock;
6914   char data[PIPESIZE];
6915   uint nread;     
6916   uint nwrite;    
6917   int readopen;   
6918   int writeopen;  
6919 };
6920 
6921 int
6922 pipealloc(struct file **f0, struct file **f1)
6923 {
6924   struct pipe *p;
6925 
6926   p = 0;
6927   *f0 = *f1 = 0;
6928   if((*f0 = filealloc()) == 0 || (*f1 = filealloc()) == 0)
6929     goto bad;
6930   if((p = (struct pipe*)kalloc()) == 0)
6931     goto bad;
6932   p->readopen = 1;
6933   p->writeopen = 1;
6934   p->nwrite = 0;
6935   p->nread = 0;
6936   initlock(&p->lock, "pipe");
6937   (*f0)->type = FD_PIPE;
6938   (*f0)->readable = 1;
6939   (*f0)->writable = 0;
6940   (*f0)->pipe = p;
6941   (*f1)->type = FD_PIPE;
6942   (*f1)->readable = 0;
6943   (*f1)->writable = 1;
6944   (*f1)->pipe = p;
6945   return 0;
6946 
6947 
6948 
6949 
6950  bad:
6951   if(p)
6952     kfree((char*)p);
6953   if(*f0)
6954     fileclose(*f0);
6955   if(*f1)
6956     fileclose(*f1);
6957   return -1;
6958 }
6959 
6960 void
6961 pipeclose(struct pipe *p, int writable)
6962 {
6963   acquire(&p->lock);
6964   if(writable){
6965     p->writeopen = 0;
6966     wakeup(&p->nread);
6967   } else {
6968     p->readopen = 0;
6969     wakeup(&p->nwrite);
6970   }
6971   if(p->readopen == 0 && p->writeopen == 0){
6972     release(&p->lock);
6973     kfree((char*)p);
6974   } else
6975     release(&p->lock);
6976 }
6977 
6978 
6979 int
6980 pipewrite(struct pipe *p, char *addr, int n)
6981 {
6982   int i;
6983 
6984   acquire(&p->lock);
6985   for(i = 0; i < n; i++){
6986     while(p->nwrite == p->nread + PIPESIZE){  
6987       if(p->readopen == 0 || myproc()->killed){
6988         release(&p->lock);
6989         return -1;
6990       }
6991       wakeup(&p->nread);
6992       sleep(&p->nwrite, &p->lock);  
6993     }
6994     p->data[p->nwrite++ % PIPESIZE] = addr[i];
6995   }
6996   wakeup(&p->nread);  
6997   release(&p->lock);
6998   return n;
6999 }
7000 int
7001 piperead(struct pipe *p, char *addr, int n)
7002 {
7003   int i;
7004 
7005   acquire(&p->lock);
7006   while(p->nread == p->nwrite && p->writeopen){  
7007     if(myproc()->killed){
7008       release(&p->lock);
7009       return -1;
7010     }
7011     sleep(&p->nread, &p->lock); 
7012   }
7013   for(i = 0; i < n; i++){  
7014     if(p->nread == p->nwrite)
7015       break;
7016     addr[i] = p->data[p->nread++ % PIPESIZE];
7017   }
7018   wakeup(&p->nwrite);  
7019   release(&p->lock);
7020   return i;
7021 }
7022 
7023 
7024 
7025 
7026 
7027 
7028 
7029 
7030 
7031 
7032 
7033 
7034 
7035 
7036 
7037 
7038 
7039 
7040 
7041 
7042 
7043 
7044 
7045 
7046 
7047 
7048 
7049 
7050 #include "types.h"
7051 #include "x86.h"
7052 
7053 void*
7054 memset(void *dst, int c, uint n)
7055 {
7056   if ((int)dst%4 == 0 && n%4 == 0){
7057     c &= 0xFF;
7058     stosl(dst, (c<<24)|(c<<16)|(c<<8)|c, n/4);
7059   } else
7060     stosb(dst, c, n);
7061   return dst;
7062 }
7063 
7064 int
7065 memcmp(const void *v1, const void *v2, uint n)
7066 {
7067   const uchar *s1, *s2;
7068 
7069   s1 = v1;
7070   s2 = v2;
7071   while(n-- > 0){
7072     if(*s1 != *s2)
7073       return *s1 - *s2;
7074     s1++, s2++;
7075   }
7076 
7077   return 0;
7078 }
7079 
7080 void*
7081 memmove(void *dst, const void *src, uint n)
7082 {
7083   const char *s;
7084   char *d;
7085 
7086   s = src;
7087   d = dst;
7088   if(s < d && s + n > d){
7089     s += n;
7090     d += n;
7091     while(n-- > 0)
7092       *--d = *--s;
7093   } else
7094     while(n-- > 0)
7095       *d++ = *s++;
7096 
7097   return dst;
7098 }
7099 
7100 
7101 void*
7102 memcpy(void *dst, const void *src, uint n)
7103 {
7104   return memmove(dst, src, n);
7105 }
7106 
7107 int
7108 strncmp(const char *p, const char *q, uint n)
7109 {
7110   while(n > 0 && *p && *p == *q)
7111     n--, p++, q++;
7112   if(n == 0)
7113     return 0;
7114   return (uchar)*p - (uchar)*q;
7115 }
7116 
7117 char*
7118 strncpy(char *s, const char *t, int n)
7119 {
7120   char *os;
7121 
7122   os = s;
7123   while(n-- > 0 && (*s++ = *t++) != 0)
7124     ;
7125   while(n-- > 0)
7126     *s++ = 0;
7127   return os;
7128 }
7129 
7130 
7131 char*
7132 safestrcpy(char *s, const char *t, int n)
7133 {
7134   char *os;
7135 
7136   os = s;
7137   if(n <= 0)
7138     return os;
7139   while(--n > 0 && (*s++ = *t++) != 0)
7140     ;
7141   *s = 0;
7142   return os;
7143 }
7144 
7145 
7146 
7147 
7148 
7149 
7150 int
7151 strlen(const char *s)
7152 {
7153   int n;
7154 
7155   for(n = 0; s[n]; n++)
7156     ;
7157   return n;
7158 }
7159 
7160 
7161 
7162 
7163 
7164 
7165 
7166 
7167 
7168 
7169 
7170 
7171 
7172 
7173 
7174 
7175 
7176 
7177 
7178 
7179 
7180 
7181 
7182 
7183 
7184 
7185 
7186 
7187 
7188 
7189 
7190 
7191 
7192 
7193 
7194 
7195 
7196 
7197 
7198 
7199 
7200 
7201 
7202 struct mp {             
7203   uchar signature[4];           
7204   void *physaddr;               
7205   uchar length;                 
7206   uchar specrev;                
7207   uchar checksum;               
7208   uchar type;                   
7209   uchar imcrp;
7210   uchar reserved[3];
7211 };
7212 
7213 struct mpconf {         
7214   uchar signature[4];           
7215   ushort length;                
7216   uchar version;                
7217   uchar checksum;               
7218   uchar product[20];            
7219   uint *oemtable;               
7220   ushort oemlength;             
7221   ushort entry;                 
7222   uint *lapicaddr;              
7223   ushort xlength;               
7224   uchar xchecksum;              
7225   uchar reserved;
7226 };
7227 
7228 struct mpproc {         
7229   uchar type;                   
7230   uchar apicid;                 
7231   uchar version;                
7232   uchar flags;                  
7233     #define MPBOOT 0x02           
7234   uchar signature[4];           
7235   uint feature;                 
7236   uchar reserved[8];
7237 };
7238 
7239 struct mpioapic {       
7240   uchar type;                   
7241   uchar apicno;                 
7242   uchar version;                
7243   uchar flags;                  
7244   uint *addr;                  
7245 };
7246 
7247 
7248 
7249 
7250 
7251 #define MPPROC    0x00  
7252 #define MPBUS     0x01  
7253 #define MPIOAPIC  0x02  
7254 #define MPIOINTR  0x03  
7255 #define MPLINTR   0x04  
7256 
7257 
7258 
7259 
7260 
7261 
7262 
7263 
7264 
7265 
7266 
7267 
7268 
7269 
7270 
7271 
7272 
7273 
7274 
7275 
7276 
7277 
7278 
7279 
7280 
7281 
7282 
7283 
7284 
7285 
7286 
7287 
7288 
7289 
7290 
7291 
7292 
7293 
7294 
7295 
7296 
7297 
7298 
7299 
7300 
7301 
7302 
7303 
7304 
7305 
7306 
7307 
7308 
7309 
7310 
7311 
7312 
7313 
7314 
7315 
7316 
7317 
7318 
7319 
7320 
7321 
7322 
7323 
7324 
7325 
7326 
7327 
7328 
7329 
7330 
7331 
7332 
7333 
7334 
7335 
7336 
7337 
7338 
7339 
7340 
7341 
7342 
7343 
7344 
7345 
7346 
7347 
7348 
7349 
7350 
7351 
7352 
7353 
7354 #include "types.h"
7355 #include "defs.h"
7356 #include "param.h"
7357 #include "memlayout.h"
7358 #include "mp.h"
7359 #include "x86.h"
7360 #include "mmu.h"
7361 #include "proc.h"
7362 
7363 struct cpu cpus[NCPU];
7364 int ncpu;
7365 uchar ioapicid;
7366 
7367 static uchar
7368 sum(uchar *addr, int len)
7369 {
7370   int i, sum;
7371 
7372   sum = 0;
7373   for(i=0; i<len; i++)
7374     sum += addr[i];
7375   return sum;
7376 }
7377 
7378 
7379 static struct mp*
7380 mpsearch1(uint a, int len)
7381 {
7382   uchar *e, *p, *addr;
7383 
7384   addr = P2V(a);
7385   e = addr+len;
7386   while(1){asm("hlt");}
7387   for(p = addr; p < e; p += sizeof(struct mp))
7388     if(memcmp(p, "_MP_", 4) == 0 && sum(p, sizeof(struct mp)) == 0)
7389       return (struct mp*)p;
7390   return 0;
7391 }
7392 
7393 
7394 
7395 
7396 
7397 
7398 
7399 
7400 
7401 
7402 
7403 
7404 
7405 static struct mp*
7406 mpsearch(void)
7407 {
7408   uchar *bda;
7409   uint p;
7410   struct mp *mp;
7411 
7412   bda = (uchar *) P2V(0x400);
7413   if((p = ((bda[0x0F]<<8)| bda[0x0E]) << 4)){
7414     if((mp = mpsearch1(p, 1024)))
7415       return mp;
7416   } else {
7417     p = ((bda[0x14]<<8)|bda[0x13])*1024;
7418     if((mp = mpsearch1(p-1024, 1024)))
7419       return mp;
7420   }
7421   return mpsearch1(0xF0000, 0x10000);
7422 }
7423 
7424 
7425 
7426 
7427 
7428 
7429 static struct mpconf*
7430 mpconfig(struct mp **pmp)
7431 {
7432   struct mpconf *conf;
7433   struct mp *mp;
7434 
7435   if((mp = mpsearch()) == 0 || mp->physaddr == 0)
7436     return 0;
7437   conf = (struct mpconf*) P2V((uint) mp->physaddr);
7438   if(memcmp(conf, "PCMP", 4) != 0)
7439     return 0;
7440   if(conf->version != 1 && conf->version != 4)
7441     return 0;
7442   if(sum((uchar*)conf, conf->length) != 0)
7443     return 0;
7444   *pmp = mp;
7445   return conf;
7446 }
7447 
7448 
7449 
7450 void
7451 mpinit(void)
7452 {
7453   uchar *p, *e;
7454   int ismp;
7455   struct mp *mp;
7456   struct mpconf *conf;
7457   struct mpproc *proc;
7458   struct mpioapic *ioapic;
7459 
7460   if((conf = mpconfig(&mp)) == 0)
7461     panic("Expect to run on an SMP");
7462   ismp = 1;
7463   lapic = (uint*)conf->lapicaddr;
7464   for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
7465     switch(*p){
7466     case MPPROC:
7467       proc = (struct mpproc*)p;
7468       if(ncpu < NCPU) {
7469         cpus[ncpu].apicid = proc->apicid;  
7470         ncpu++;
7471       }
7472       p += sizeof(struct mpproc);
7473       continue;
7474     case MPIOAPIC:
7475       ioapic = (struct mpioapic*)p;
7476       ioapicid = ioapic->apicno;
7477       p += sizeof(struct mpioapic);
7478       continue;
7479     case MPBUS:
7480     case MPIOINTR:
7481     case MPLINTR:
7482       p += 8;
7483       continue;
7484     default:
7485       ismp = 0;
7486       break;
7487     }
7488   }
7489   if(!ismp)
7490     panic("Didn't find a suitable machine");
7491 
7492   if(mp->imcrp){
7493     
7494     
7495     outb(0x22, 0x70);   
7496     outb(0x23, inb(0x23) | 1);  
7497   }
7498 }
7499 
7500 
7501 
7502 
7503 #include "param.h"
7504 #include "types.h"
7505 #include "defs.h"
7506 #include "date.h"
7507 #include "memlayout.h"
7508 #include "traps.h"
7509 #include "mmu.h"
7510 #include "x86.h"
7511 #include "debug.h"
7512 
7513 #define ID      (0x0020/4)   
7514 #define VER     (0x0030/4)   
7515 #define TPR     (0x0080/4)   
7516 #define EOI     (0x00B0/4)   
7517 #define SVR     (0x00F0/4)   
7518   #define ENABLE     0x00000100   
7519 #define ESR     (0x0280/4)   
7520 #define ICRLO   (0x0300/4)   
7521   #define INIT       0x00000500   
7522   #define STARTUP    0x00000600   
7523   #define DELIVS     0x00001000   
7524   #define ASSERT     0x00004000   
7525   #define DEASSERT   0x00000000
7526   #define LEVEL      0x00008000   
7527   #define BCAST      0x00080000   
7528   #define BUSY       0x00001000
7529   #define FIXED      0x00000000
7530 #define ICRHI   (0x0310/4)   
7531 #define TIMER   (0x0320/4)   
7532   #define X1         0x0000000B   
7533   #define PERIODIC   0x00020000   
7534 #define PCINT   (0x0340/4)   
7535 #define LINT0   (0x0350/4)   
7536 #define LINT1   (0x0360/4)   
7537 #define ERROR   (0x0370/4)   
7538   #define MASKED     0x00010000   
7539 #define TICR    (0x0380/4)   
7540 #define TCCR    (0x0390/4)   
7541 #define TDCR    (0x03E0/4)   
7542 
7543 volatile uint *lapic;  
7544 
7545 
7546 
7547 
7548 
7549 
7550 static void
7551 lapicw(int index, int value)
7552 {
7553   lapic[index] = value;
7554   lapic[ID];  
7555 }
7556 
7557 void
7558 lapicinit(void)
7559 {
7560   if(!lapic)
7561     return;
7562 
7563   
7564   lapicw(SVR, ENABLE | (T_IRQ0 + IRQ_SPURIOUS));
7565 
7566   
7567   
7568   
7569   
7570   lapicw(TDCR, X1);
7571   lapicw(TIMER, PERIODIC | (T_IRQ0 + IRQ_TIMER));
7572   lapicw(TICR, 10000000);
7573 
7574   
7575   lapicw(LINT0, MASKED);
7576   lapicw(LINT1, MASKED);
7577 
7578   
7579   
7580   if(((lapic[VER]>>16) & 0xFF) >= 4)
7581     lapicw(PCINT, MASKED);
7582 
7583   
7584   lapicw(ERROR, T_IRQ0 + IRQ_ERROR);
7585 
7586   
7587   lapicw(ESR, 0);
7588   lapicw(ESR, 0);
7589 
7590   
7591   lapicw(EOI, 0);
7592 
7593   
7594   lapicw(ICRHI, 0);
7595   lapicw(ICRLO, BCAST | INIT | LEVEL);
7596   while(lapic[ICRLO] & DELIVS)
7597     ;
7598 
7599 
7600   
7601   lapicw(TPR, 0);
7602 }
7603 
7604 int
7605 lapicid(void)
7606 {
7607 
7608   if (!lapic){
7609     return 0;
7610   }
7611   return lapic[ID] >> 24;
7612 }
7613 
7614 
7615 void
7616 lapiceoi(void)
7617 {
7618   if(lapic)
7619     lapicw(EOI, 0);
7620 }
7621 
7622 
7623 
7624 void
7625 microdelay(int us)
7626 {
7627 }
7628 
7629 #define CMOS_PORT    0x70
7630 #define CMOS_RETURN  0x71
7631 
7632 
7633 
7634 void
7635 lapicstartap(uchar apicid, uint addr)
7636 {
7637   int i;
7638   ushort *wrv;
7639 
7640   
7641   
7642   
7643   outb(CMOS_PORT, 0xF);  
7644   outb(CMOS_PORT+1, 0x0A);
7645   wrv = (ushort*)P2V((0x40<<4 | 0x67));  
7646   wrv[0] = 0;
7647   wrv[1] = addr >> 4;
7648 
7649 
7650   
7651   
7652   lapicw(ICRHI, apicid<<24);
7653   lapicw(ICRLO, INIT | LEVEL | ASSERT);
7654   microdelay(200);
7655   lapicw(ICRLO, INIT | LEVEL);
7656   microdelay(100);    
7657 
7658   
7659   
7660   
7661   
7662   
7663   for(i = 0; i < 2; i++){
7664     lapicw(ICRHI, apicid<<24);
7665     lapicw(ICRLO, STARTUP | (addr>>12));
7666     microdelay(200);
7667   }
7668 }
7669 
7670 #define CMOS_STATA   0x0a
7671 #define CMOS_STATB   0x0b
7672 #define CMOS_UIP    (1 << 7)        
7673 
7674 #define SECS    0x00
7675 #define MINS    0x02
7676 #define HOURS   0x04
7677 #define DAY     0x07
7678 #define MONTH   0x08
7679 #define YEAR    0x09
7680 
7681 static uint cmos_read(uint reg)
7682 {
7683   outb(CMOS_PORT,  reg);
7684   microdelay(200);
7685 
7686   return inb(CMOS_RETURN);
7687 }
7688 
7689 static void fill_rtcdate(struct rtcdate *r)
7690 {
7691   r->second = cmos_read(SECS);
7692   r->minute = cmos_read(MINS);
7693   r->hour   = cmos_read(HOURS);
7694   r->day    = cmos_read(DAY);
7695   r->month  = cmos_read(MONTH);
7696   r->year   = cmos_read(YEAR);
7697 }
7698 
7699 
7700 
7701 void cmostime(struct rtcdate *r)
7702 {
7703   struct rtcdate t1, t2;
7704   int sb, bcd;
7705 
7706   sb = cmos_read(CMOS_STATB);
7707 
7708   bcd = (sb & (1 << 2)) == 0;
7709 
7710   
7711   for(;;) {
7712     fill_rtcdate(&t1);
7713     if(cmos_read(CMOS_STATA) & CMOS_UIP)
7714         continue;
7715     fill_rtcdate(&t2);
7716     if(memcmp(&t1, &t2, sizeof(t1)) == 0)
7717       break;
7718   }
7719 
7720   
7721   if(bcd) {
7722 #define    CONV(x)     (t1.x = ((t1.x >> 4) * 10) + (t1.x & 0xf))
7723     CONV(second);
7724     CONV(minute);
7725     CONV(hour  );
7726     CONV(day   );
7727     CONV(month );
7728     CONV(year  );
7729 #undef     CONV
7730   }
7731 
7732   *r = t1;
7733   r->year += 2000;
7734 }
7735 
7736 
7737 
7738 
7739 
7740 
7741 
7742 
7743 
7744 
7745 
7746 
7747 
7748 
7749 
7750 
7751 
7752 
7753 
7754 #include "types.h"
7755 #include "defs.h"
7756 #include "traps.h"
7757 
7758 #define IOAPIC  0xFEC00000   
7759 
7760 #define REG_ID     0x00  
7761 #define REG_VER    0x01  
7762 #define REG_TABLE  0x10  
7763 
7764 
7765 
7766 
7767 
7768 
7769 #define INT_DISABLED   0x00010000  
7770 #define INT_LEVEL      0x00008000  
7771 #define INT_ACTIVELOW  0x00002000  
7772 #define INT_LOGICAL    0x00000800  
7773 
7774 volatile struct ioapic *ioapic;
7775 
7776 
7777 struct ioapic {
7778   uint reg;
7779   uint pad[3];
7780   uint data;
7781 };
7782 
7783 static uint
7784 ioapicread(int reg)
7785 {
7786   ioapic->reg = reg;
7787   return ioapic->data;
7788 }
7789 
7790 static void
7791 ioapicwrite(int reg, uint data)
7792 {
7793   ioapic->reg = reg;
7794   ioapic->data = data;
7795 }
7796 
7797 
7798 
7799 
7800 void
7801 ioapicinit(void)
7802 {
7803   int i, id, maxintr;
7804 
7805   ioapic = (volatile struct ioapic*)IOAPIC;
7806   maxintr = (ioapicread(REG_VER) >> 16) & 0xFF;
7807   id = ioapicread(REG_ID) >> 24;
7808   if(id != ioapicid)
7809     cprintf("ioapicinit: id isn't equal to ioapicid; not a MP\n");
7810 
7811   
7812   
7813   for(i = 0; i <= maxintr; i++){
7814     ioapicwrite(REG_TABLE+2*i, INT_DISABLED | (T_IRQ0 + i));
7815     ioapicwrite(REG_TABLE+2*i+1, 0);
7816   }
7817 }
7818 
7819 void
7820 ioapicenable(int irq, int cpunum)
7821 {
7822   
7823   
7824   
7825   ioapicwrite(REG_TABLE+2*irq, T_IRQ0 + irq);
7826   ioapicwrite(REG_TABLE+2*irq+1, cpunum << 24);
7827 }
7828 
7829 
7830 
7831 
7832 
7833 
7834 
7835 
7836 
7837 
7838 
7839 
7840 
7841 
7842 
7843 
7844 
7845 
7846 
7847 
7848 
7849 
7850 
7851 
7852 #define KBSTATP         0x64    
7853 #define KBS_DIB         0x01    
7854 #define KBDATAP         0x60    
7855 
7856 #define NO              0
7857 
7858 #define SHIFT           (1<<0)
7859 #define CTL             (1<<1)
7860 #define ALT             (1<<2)
7861 
7862 #define CAPSLOCK        (1<<3)
7863 #define NUMLOCK         (1<<4)
7864 #define SCROLLLOCK      (1<<5)
7865 
7866 #define E0ESC           (1<<6)
7867 
7868 
7869 #define KEY_HOME        0xE0
7870 #define KEY_END         0xE1
7871 #define KEY_UP          0xE2
7872 #define KEY_DN          0xE3
7873 #define KEY_LF          0xE4
7874 #define KEY_RT          0xE5
7875 #define KEY_PGUP        0xE6
7876 #define KEY_PGDN        0xE7
7877 #define KEY_INS         0xE8
7878 #define KEY_DEL         0xE9
7879 
7880 
7881 #define C(x) (x - '@')
7882 
7883 static uchar shiftcode[256] =
7884 {
7885   [0x1D] CTL,
7886   [0x2A] SHIFT,
7887   [0x36] SHIFT,
7888   [0x38] ALT,
7889   [0x9D] CTL,
7890   [0xB8] ALT
7891 };
7892 
7893 static uchar togglecode[256] =
7894 {
7895   [0x3A] CAPSLOCK,
7896   [0x45] NUMLOCK,
7897   [0x46] SCROLLLOCK
7898 };
7899 
7900 static uchar normalmap[256] =
7901 {
7902   NO,   0x1B, '1',  '2',  '3',  '4',  '5',  '6',  
7903   '7',  '8',  '9',  '0',  '-',  '=',  '\b', '\t',
7904   'q',  'w',  'e',  'r',  't',  'y',  'u',  'i',  
7905   'o',  'p',  '[',  ']',  '\n', NO,   'a',  's',
7906   'd',  'f',  'g',  'h',  'j',  'k',  'l',  ';',  
7907   '\'', '`',  NO,   '\\', 'z',  'x',  'c',  'v',
7908   'b',  'n',  'm',  ',',  '.',  '/',  NO,   '*',  
7909   NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
7910   NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  
7911   '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
7912   '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   
7913   [0x9C] '\n',      
7914   [0xB5] '/',       
7915   [0xC8] KEY_UP,    [0xD0] KEY_DN,
7916   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
7917   [0xCB] KEY_LF,    [0xCD] KEY_RT,
7918   [0x97] KEY_HOME,  [0xCF] KEY_END,
7919   [0xD2] KEY_INS,   [0xD3] KEY_DEL
7920 };
7921 
7922 static uchar shiftmap[256] =
7923 {
7924   NO,   033,  '!',  '@',  '#',  '$',  '%',  '^',  
7925   '&',  '*',  '(',  ')',  '_',  '+',  '\b', '\t',
7926   'Q',  'W',  'E',  'R',  'T',  'Y',  'U',  'I',  
7927   'O',  'P',  '{',  '}',  '\n', NO,   'A',  'S',
7928   'D',  'F',  'G',  'H',  'J',  'K',  'L',  ':',  
7929   '"',  '~',  NO,   '|',  'Z',  'X',  'C',  'V',
7930   'B',  'N',  'M',  '<',  '>',  '?',  NO,   '*',  
7931   NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
7932   NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  
7933   '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
7934   '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   
7935   [0x9C] '\n',      
7936   [0xB5] '/',       
7937   [0xC8] KEY_UP,    [0xD0] KEY_DN,
7938   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
7939   [0xCB] KEY_LF,    [0xCD] KEY_RT,
7940   [0x97] KEY_HOME,  [0xCF] KEY_END,
7941   [0xD2] KEY_INS,   [0xD3] KEY_DEL
7942 };
7943 
7944 
7945 
7946 
7947 
7948 
7949 
7950 static uchar ctlmap[256] =
7951 {
7952   NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
7953   NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
7954   C('Q'),  C('W'),  C('E'),  C('R'),  C('T'),  C('Y'),  C('U'),  C('I'),
7955   C('O'),  C('P'),  NO,      NO,      '\r',    NO,      C('A'),  C('S'),
7956   C('D'),  C('F'),  C('G'),  C('H'),  C('J'),  C('K'),  C('L'),  NO,
7957   NO,      NO,      NO,      C('\\'), C('Z'),  C('X'),  C('C'),  C('V'),
7958   C('B'),  C('N'),  C('M'),  NO,      NO,      C('/'),  NO,      NO,
7959   [0x9C] '\r',      
7960   [0xB5] C('/'),    
7961   [0xC8] KEY_UP,    [0xD0] KEY_DN,
7962   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
7963   [0xCB] KEY_LF,    [0xCD] KEY_RT,
7964   [0x97] KEY_HOME,  [0xCF] KEY_END,
7965   [0xD2] KEY_INS,   [0xD3] KEY_DEL
7966 };
7967 
7968 
7969 
7970 
7971 
7972 
7973 
7974 
7975 
7976 
7977 
7978 
7979 
7980 
7981 
7982 
7983 
7984 
7985 
7986 
7987 
7988 
7989 
7990 
7991 
7992 
7993 
7994 
7995 
7996 
7997 
7998 
7999 
8000 #include "types.h"
8001 #include "x86.h"
8002 #include "defs.h"
8003 #include "kbd.h"
8004 
8005 int
8006 kbdgetc(void)
8007 {
8008   static uint shift;
8009   static uchar *charcode[4] = {
8010     normalmap, shiftmap, ctlmap, ctlmap
8011   };
8012   uint st, data, c;
8013 
8014   st = inb(KBSTATP);
8015   if((st & KBS_DIB) == 0)
8016     return -1;
8017   data = inb(KBDATAP);
8018 
8019   if(data == 0xE0){
8020     shift |= E0ESC;
8021     return 0;
8022   } else if(data & 0x80){
8023     
8024     data = (shift & E0ESC ? data : data & 0x7F);
8025     shift &= ~(shiftcode[data] | E0ESC);
8026     return 0;
8027   } else if(shift & E0ESC){
8028     
8029     data |= 0x80;
8030     shift &= ~E0ESC;
8031   }
8032 
8033   shift |= shiftcode[data];
8034   shift ^= togglecode[data];
8035   c = charcode[shift & (CTL | SHIFT)][data];
8036   if(shift & CAPSLOCK){
8037     if('a' <= c && c <= 'z')
8038       c += 'A' - 'a';
8039     else if('A' <= c && c <= 'Z')
8040       c += 'a' - 'A';
8041   }
8042   return c;
8043 }
8044 
8045 void
8046 kbdintr(void)
8047 {
8048   consoleintr(kbdgetc);
8049 }
8050 
8051 
8052 
8053 
8054 #include "types.h"
8055 #include "defs.h"
8056 #include "param.h"
8057 #include "traps.h"
8058 #include "spinlock.h"
8059 #include "sleeplock.h"
8060 #include "fs.h"
8061 #include "file.h"
8062 #include "memlayout.h"
8063 #include "mmu.h"
8064 #include "proc.h"
8065 #include "x86.h"
8066 #include "font.h"
8067 #include "graphic.h"
8068 
8069 static void consputc(int);
8070 
8071 static int panicked = 0;
8072 
8073 static struct {
8074   struct spinlock lock;
8075   int locking;
8076 } cons;
8077 
8078 static void
8079 printint(int xx, int base, int sign)
8080 {
8081   static char digits[] = "0123456789abcdef";
8082   char buf[16];
8083   int i;
8084   uint x;
8085 
8086   if(sign && (sign = xx < 0))
8087     x = -xx;
8088   else
8089     x = xx;
8090 
8091   i = 0;
8092   do{
8093     buf[i++] = digits[x % base];
8094   }while((x /= base) != 0);
8095 
8096   if(sign)
8097     buf[i++] = '-';
8098 
8099 
8100   while(--i >= 0)
8101     consputc(buf[i]);
8102 }
8103 
8104 
8105 
8106 
8107 
8108 
8109 
8110 
8111 
8112 
8113 
8114 
8115 
8116 
8117 
8118 
8119 
8120 
8121 
8122 
8123 
8124 
8125 
8126 
8127 
8128 
8129 
8130 
8131 
8132 
8133 
8134 
8135 
8136 
8137 
8138 
8139 
8140 
8141 
8142 
8143 
8144 
8145 
8146 
8147 
8148 
8149 
8150 
8151 void
8152 cprintf(char *fmt, ...)
8153 {
8154   int i, c, locking;
8155   uint *argp;
8156   char *s;
8157 
8158   locking = cons.locking;
8159   if(locking)
8160     acquire(&cons.lock);
8161 
8162   if (fmt == 0)
8163     panic("null fmt");
8164 
8165 
8166   argp = (uint*)(void*)(&fmt + 1);
8167   for(i = 0; (c = fmt[i] & 0xff) != 0; i++){
8168     if(c != '%'){
8169       consputc(c);
8170       continue;
8171     }
8172     c = fmt[++i] & 0xff;
8173     if(c == 0)
8174       break;
8175     switch(c){
8176     case 'd':
8177       printint(*argp++, 10, 1);
8178       break;
8179     case 'x':
8180     case 'p':
8181       printint(*argp++, 16, 0);
8182       break;
8183     case 's':
8184       if((s = (char*)*argp++) == 0)
8185         s = "(null)";
8186       for(; *s; s++)
8187         consputc(*s);
8188       break;
8189     case '%':
8190       consputc('%');
8191       break;
8192     default:
8193       
8194       consputc('%');
8195       consputc(c);
8196       break;
8197     }
8198   }
8199 
8200   if(locking)
8201     release(&cons.lock);
8202 }
8203 
8204 void
8205 panic(char *s)
8206 {
8207   int i;
8208   uint pcs[10];
8209 
8210   cli();
8211   cons.locking = 0;
8212   
8213   cprintf("lapicid %d: panic: ", lapicid());
8214   cprintf(s);
8215   cprintf("\n");
8216   getcallerpcs(&s, pcs);
8217   for(i=0; i<10; i++)
8218     cprintf(" %p", pcs[i]);
8219   panicked = 1; 
8220   for(;;)
8221     ;
8222 }
8223 
8224 
8225 
8226 
8227 
8228 
8229 
8230 
8231 
8232 
8233 
8234 
8235 
8236 
8237 
8238 
8239 
8240 
8241 
8242 
8243 
8244 
8245 
8246 
8247 
8248 
8249 
8250 #define BACKSPACE 0x100
8251 #define CRTPORT 0x3d4
8252 /*static ushort *crt = (ushort*)P2V(0xb8000);  
8253 
8254 static void
8255 cgaputc(int c)
8256 {
8257   int pos;
8258 
8259   
8260   outb(CRTPORT, 14);
8261   pos = inb(CRTPORT+1) << 8;
8262   outb(CRTPORT, 15);
8263   pos |= inb(CRTPORT+1);
8264 
8265   if(c == '\n')
8266     pos += 80 - pos%80;
8267   else if(c == BACKSPACE){
8268     if(pos > 0) --pos;
8269   } else
8270     crt[pos++] = (c&0xff) | 0x0700;  
8271 
8272   if(pos < 0 || pos > 25*80)
8273     panic("pos under/overflow");
8274 
8275   if((pos/80) >= 24){  
8276     memmove(crt, crt+80, sizeof(crt[0])*23*80);
8277     pos -= 80;
8278     memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
8279   }
8280 
8281   outb(CRTPORT, 14);
8282   outb(CRTPORT+1, pos>>8);
8283   outb(CRTPORT, 15);
8284   outb(CRTPORT+1, pos);
8285   crt[pos] = ' ' | 0x0700;
8286 }*/
8287 
8288 
8289 #define CONSOLE_HORIZONTAL_MAX 53
8290 #define CONSOLE_VERTICAL_MAX 20
8291 int console_pos = CONSOLE_HORIZONTAL_MAX*(CONSOLE_VERTICAL_MAX);
8292 
8293 void graphic_putc(int c){
8294   if(c == '\n'){
8295     console_pos += CONSOLE_HORIZONTAL_MAX - console_pos%CONSOLE_HORIZONTAL_MAX;
8296     if(console_pos >= CONSOLE_VERTICAL_MAX * CONSOLE_HORIZONTAL_MAX){
8297       console_pos -= CONSOLE_HORIZONTAL_MAX;
8298       graphic_scroll_up(30);
8299     }
8300   }else if(c == BACKSPACE){
8301     if(console_pos>0) --console_pos;
8302   }else{
8303     if(console_pos >= CONSOLE_VERTICAL_MAX * CONSOLE_HORIZONTAL_MAX){
8304       console_pos -= CONSOLE_HORIZONTAL_MAX;
8305       graphic_scroll_up(30);
8306     }
8307     int x = (console_pos%CONSOLE_HORIZONTAL_MAX)*FONT_WIDTH + 2;
8308     int y = (console_pos/CONSOLE_HORIZONTAL_MAX)*FONT_HEIGHT;
8309     font_render(x,y,c);
8310     console_pos++;
8311   }
8312 }
8313 
8314 
8315 void
8316 consputc(int c)
8317 {
8318   if(panicked){
8319     cli();
8320     for(;;)
8321       ;
8322   }
8323 
8324   if(c == BACKSPACE){
8325     uartputc('\b'); uartputc(' '); uartputc('\b');
8326   } else {
8327     uartputc(c);
8328   }
8329   graphic_putc(c);
8330 }
8331 
8332 #define INPUT_BUF 128
8333 struct {
8334   char buf[INPUT_BUF];
8335   uint r;  
8336   uint w;  
8337   uint e;  
8338 } input;
8339 
8340 #define C(x)  ((x)-'@')  
8341 
8342 void
8343 consoleintr(int (*getc)(void))
8344 {
8345   int c, doprocdump = 0;
8346 
8347   acquire(&cons.lock);
8348   while((c = getc()) >= 0){
8349     switch(c){
8350     case C('P'):  
8351       
8352       doprocdump = 1;
8353       break;
8354     case C('U'):  
8355       while(input.e != input.w &&
8356             input.buf[(input.e-1) % INPUT_BUF] != '\n'){
8357         input.e--;
8358         consputc(BACKSPACE);
8359       }
8360       break;
8361     case C('H'): case '\x7f':  
8362       if(input.e != input.w){
8363         input.e--;
8364         consputc(BACKSPACE);
8365       }
8366       break;
8367     default:
8368       if(c != 0 && input.e-input.r < INPUT_BUF){
8369         c = (c == '\r') ? '\n' : c;
8370         input.buf[input.e++ % INPUT_BUF] = c;
8371         consputc(c);
8372         if(c == '\n' || c == C('D') || input.e == input.r+INPUT_BUF){
8373           input.w = input.e;
8374           wakeup(&input.r);
8375         }
8376       }
8377       break;
8378     }
8379   }
8380   release(&cons.lock);
8381   if(doprocdump) {
8382     procdump();  
8383   }
8384 }
8385 
8386 
8387 
8388 
8389 
8390 
8391 
8392 
8393 
8394 
8395 
8396 
8397 
8398 
8399 
8400 int
8401 consoleread(struct inode *ip, char *dst, int n)
8402 {
8403   uint target;
8404   int c;
8405 
8406   iunlock(ip);
8407   target = n;
8408   acquire(&cons.lock);
8409   while(n > 0){
8410     while(input.r == input.w){
8411       if(myproc()->killed){
8412         release(&cons.lock);
8413         ilock(ip);
8414         return -1;
8415       }
8416       sleep(&input.r, &cons.lock);
8417     }
8418     c = input.buf[input.r++ % INPUT_BUF];
8419     if(c == C('D')){  
8420       if(n < target){
8421         
8422         
8423         input.r--;
8424       }
8425       break;
8426     }
8427     *dst++ = c;
8428     --n;
8429     if(c == '\n')
8430       break;
8431   }
8432   release(&cons.lock);
8433   ilock(ip);
8434 
8435   return target - n;
8436 }
8437 
8438 
8439 
8440 
8441 
8442 
8443 
8444 
8445 
8446 
8447 
8448 
8449 
8450 int
8451 consolewrite(struct inode *ip, char *buf, int n)
8452 {
8453   int i;
8454 
8455   iunlock(ip);
8456   acquire(&cons.lock);
8457   for(i = 0; i < n; i++)
8458     consputc(buf[i] & 0xff);
8459   release(&cons.lock);
8460   ilock(ip);
8461 
8462   return n;
8463 }
8464 
8465 void
8466 consoleinit(void)
8467 {
8468   panicked = 0;
8469   initlock(&cons.lock, "console");
8470 
8471   devsw[CONSOLE].write = consolewrite;
8472   devsw[CONSOLE].read = consoleread;
8473 
8474   char *p;
8475   for(p="Starting XV6_UEFI...\n"; *p; p++)
8476     graphic_putc(*p);
8477 
8478   cons.locking = 1;
8479 
8480   ioapicenable(IRQ_KBD, 0);
8481 }
8482 
8483 
8484 
8485 
8486 
8487 
8488 
8489 
8490 
8491 
8492 
8493 
8494 
8495 
8496 
8497 
8498 
8499 
8500 
8501 
8502 #include "types.h"
8503 #include "defs.h"
8504 #include "param.h"
8505 #include "traps.h"
8506 #include "spinlock.h"
8507 #include "sleeplock.h"
8508 #include "fs.h"
8509 #include "file.h"
8510 #include "mmu.h"
8511 #include "proc.h"
8512 #include "x86.h"
8513 
8514 #define COM1    0x3f8
8515 
8516 static int uart;    
8517 
8518 void
8519 uartinit(void)
8520 {
8521   char *p;
8522 
8523   
8524   outb(COM1+2, 0);
8525 
8526   
8527   outb(COM1+3, 0x80);    
8528   outb(COM1+0, 115200/9600);
8529   outb(COM1+1, 0);
8530   outb(COM1+3, 0x03);    
8531   outb(COM1+4, 0);
8532   outb(COM1+1, 0x01);    
8533 
8534   
8535   if(inb(COM1+5) == 0xFF)
8536     return;
8537   uart = 1;
8538 
8539   
8540   
8541   inb(COM1+2);
8542   inb(COM1+0);
8543   ioapicenable(IRQ_COM1, 0);
8544 
8545   
8546   for(p="xv6...\n"; *p; p++)
8547     uartputc(*p);
8548 }
8549 
8550 void
8551 uartputc(int c)
8552 {
8553   int i;
8554 
8555   if(!uart)
8556     return;
8557   for(i = 0; i < 128 && !(inb(COM1+5) & 0x20); i++)
8558     microdelay(10);
8559   outb(COM1+0, c);
8560 }
8561 
8562 static int
8563 uartgetc(void)
8564 {
8565   if(!uart)
8566     return -1;
8567   if(!(inb(COM1+5) & 0x01))
8568     return -1;
8569   return inb(COM1+0);
8570 }
8571 
8572 void
8573 uartintr(void)
8574 {
8575   consoleintr(uartgetc);
8576 }
8577 
8578 
8579 
8580 
8581 
8582 
8583 
8584 
8585 
8586 
8587 
8588 
8589 
8590 
8591 
8592 
8593 
8594 
8595 
8596 
8597 
8598 
8599 
8600 
8601 
8602 
8603 
8604 
8605 
8606 
8607 
8608 .globl start
8609 start:
8610   pushl $argv
8611   pushl $init
8612   pushl $0  
8613   movl $SYS_exec, %eax
8614   int $T_SYSCALL
8615 
8616 
8617 exit:
8618   movl $SYS_exit, %eax
8619   int $T_SYSCALL
8620   jmp exit
8621 
8622 
8623 init:
8624   .string "/init\0"
8625 
8626 
8627 .p2align 2
8628 argv:
8629   .long init
8630   .long 0
8631 
8632 
8633 
8634 
8635 
8636 
8637 
8638 
8639 
8640 
8641 
8642 
8643 
8644 
8645 
8646 
8647 
8648 
8649 
8650 
8651 
8652 
8653 
8654   .globl name; \
8655   name: \
8656     movl $SYS_ 
8657     int $T_SYSCALL; \
8658     ret
8659 
8660 SYSCALL(fork)
8661 SYSCALL(exit)
8662 SYSCALL(wait)
8663 SYSCALL(pipe)
8664 SYSCALL(read)
8665 SYSCALL(write)
8666 SYSCALL(close)
8667 SYSCALL(kill)
8668 SYSCALL(exec)
8669 SYSCALL(open)
8670 SYSCALL(mknod)
8671 SYSCALL(unlink)
8672 SYSCALL(fstat)
8673 SYSCALL(link)
8674 SYSCALL(mkdir)
8675 SYSCALL(chdir)
8676 SYSCALL(dup)
8677 SYSCALL(getpid)
8678 SYSCALL(sbrk)
8679 SYSCALL(sleep)
8680 SYSCALL(uptime)
8681 SYSCALL(printpt)
8682 
8683 
8684 
8685 
8686 
8687 
8688 
8689 
8690 
8691 
8692 
8693 
8694 
8695 
8696 
8697 
8698 
8699 
8700 
8701 
8702 #include "types.h"
8703 #include "stat.h"
8704 #include "user.h"
8705 #include "fcntl.h"
8706 
8707 char *argv[] = { "sh", 0 };
8708 
8709 int
8710 main(void)
8711 {
8712   int pid, wpid;
8713 
8714   if(open("console", O_RDWR) < 0){
8715     mknod("console", 1, 1);
8716     open("console", O_RDWR);
8717   }
8718   dup(0);  
8719   dup(0);  
8720 
8721   for(;;){
8722     printf(1, "init: starting sh\n");
8723     pid = fork();
8724     if(pid < 0){
8725       printf(1, "init: fork failed\n");
8726       exit();
8727     }
8728     if(pid == 0){
8729       exec("sh", argv);
8730       printf(1, "init: exec sh failed\n");
8731       exit();
8732     }
8733     while((wpid=wait()) >= 0 && wpid != pid)
8734       printf(1, "zombie!\n");
8735   }
8736 }
8737 
8738 
8739 
8740 
8741 
8742 
8743 
8744 
8745 
8746 
8747 
8748 
8749 
8750 
8751 
8752 #include "types.h"
8753 #include "user.h"
8754 #include "fcntl.h"
8755 
8756 
8757 #define EXEC  1
8758 #define REDIR 2
8759 #define PIPE  3
8760 #define LIST  4
8761 #define BACK  5
8762 
8763 #define MAXARGS 10
8764 
8765 struct cmd {
8766   int type;
8767 };
8768 
8769 struct execcmd {
8770   int type;
8771   char *argv[MAXARGS];
8772   char *eargv[MAXARGS];
8773 };
8774 
8775 struct redircmd {
8776   int type;
8777   struct cmd *cmd;
8778   char *file;
8779   char *efile;
8780   int mode;
8781   int fd;
8782 };
8783 
8784 struct pipecmd {
8785   int type;
8786   struct cmd *left;
8787   struct cmd *right;
8788 };
8789 
8790 struct listcmd {
8791   int type;
8792   struct cmd *left;
8793   struct cmd *right;
8794 };
8795 
8796 struct backcmd {
8797   int type;
8798   struct cmd *cmd;
8799 };
8800 int fork1(void);  
8801 void panic(char*);
8802 struct cmd *parsecmd(char*);
8803 
8804 
8805 void
8806 runcmd(struct cmd *cmd)
8807 {
8808   int p[2];
8809   struct backcmd *bcmd;
8810   struct execcmd *ecmd;
8811   struct listcmd *lcmd;
8812   struct pipecmd *pcmd;
8813   struct redircmd *rcmd;
8814 
8815   if(cmd == 0)
8816     exit();
8817 
8818   switch(cmd->type){
8819   default:
8820     panic("runcmd");
8821 
8822   case EXEC:
8823     ecmd = (struct execcmd*)cmd;
8824     if(ecmd->argv[0] == 0)
8825       exit();
8826     exec(ecmd->argv[0], ecmd->argv);
8827     printf(2, "exec %s failed\n", ecmd->argv[0]);
8828     break;
8829 
8830   case REDIR:
8831     rcmd = (struct redircmd*)cmd;
8832     close(rcmd->fd);
8833     if(open(rcmd->file, rcmd->mode) < 0){
8834       printf(2, "open %s failed\n", rcmd->file);
8835       exit();
8836     }
8837     runcmd(rcmd->cmd);
8838     break;
8839 
8840   case LIST:
8841     lcmd = (struct listcmd*)cmd;
8842     if(fork1() == 0)
8843       runcmd(lcmd->left);
8844     wait();
8845     runcmd(lcmd->right);
8846     break;
8847 
8848 
8849 
8850   case PIPE:
8851     pcmd = (struct pipecmd*)cmd;
8852     if(pipe(p) < 0)
8853       panic("pipe");
8854     if(fork1() == 0){
8855       close(1);
8856       dup(p[1]);
8857       close(p[0]);
8858       close(p[1]);
8859       runcmd(pcmd->left);
8860     }
8861     if(fork1() == 0){
8862       close(0);
8863       dup(p[0]);
8864       close(p[0]);
8865       close(p[1]);
8866       runcmd(pcmd->right);
8867     }
8868     close(p[0]);
8869     close(p[1]);
8870     wait();
8871     wait();
8872     break;
8873 
8874   case BACK:
8875     bcmd = (struct backcmd*)cmd;
8876     if(fork1() == 0)
8877       runcmd(bcmd->cmd);
8878     break;
8879   }
8880   exit();
8881 }
8882 
8883 int
8884 getcmd(char *buf, int nbuf)
8885 {
8886   printf(2, "$ ");
8887   memset(buf, 0, nbuf);
8888   gets(buf, nbuf);
8889   if(buf[0] == 0) 
8890     return -1;
8891   return 0;
8892 }
8893 
8894 
8895 
8896 
8897 
8898 
8899 
8900 int
8901 main(void)
8902 {
8903   static char buf[100];
8904   int fd;
8905 
8906   
8907   while((fd = open("console", O_RDWR)) >= 0){
8908     if(fd >= 3){
8909       close(fd);
8910       break;
8911     }
8912   }
8913 
8914   
8915   while(getcmd(buf, sizeof(buf)) >= 0){
8916     if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
8917       
8918       buf[strlen(buf)-1] = 0;  
8919       if(chdir(buf+3) < 0)
8920         printf(2, "cannot cd %s\n", buf+3);
8921       continue;
8922     }
8923     if(fork1() == 0)
8924       runcmd(parsecmd(buf));
8925     wait();
8926   }
8927   exit();
8928 }
8929 
8930 void
8931 panic(char *s)
8932 {
8933   printf(2, "%s\n", s);
8934   exit();
8935 }
8936 
8937 int
8938 fork1(void)
8939 {
8940   int pid;
8941 
8942   pid = fork();
8943   if(pid == -1)
8944     panic("fork");
8945   return pid;
8946 }
8947 
8948 
8949 
8950 
8951 
8952 struct cmd*
8953 execcmd(void)
8954 {
8955   struct execcmd *cmd;
8956 
8957   cmd = malloc(sizeof(*cmd));
8958   memset(cmd, 0, sizeof(*cmd));
8959   cmd->type = EXEC;
8960   return (struct cmd*)cmd;
8961 }
8962 
8963 struct cmd*
8964 redircmd(struct cmd *subcmd, char *file, char *efile, int mode, int fd)
8965 {
8966   struct redircmd *cmd;
8967 
8968   cmd = malloc(sizeof(*cmd));
8969   memset(cmd, 0, sizeof(*cmd));
8970   cmd->type = REDIR;
8971   cmd->cmd = subcmd;
8972   cmd->file = file;
8973   cmd->efile = efile;
8974   cmd->mode = mode;
8975   cmd->fd = fd;
8976   return (struct cmd*)cmd;
8977 }
8978 
8979 struct cmd*
8980 pipecmd(struct cmd *left, struct cmd *right)
8981 {
8982   struct pipecmd *cmd;
8983 
8984   cmd = malloc(sizeof(*cmd));
8985   memset(cmd, 0, sizeof(*cmd));
8986   cmd->type = PIPE;
8987   cmd->left = left;
8988   cmd->right = right;
8989   return (struct cmd*)cmd;
8990 }
8991 
8992 
8993 
8994 
8995 
8996 
8997 
8998 
8999 
9000 struct cmd*
9001 listcmd(struct cmd *left, struct cmd *right)
9002 {
9003   struct listcmd *cmd;
9004 
9005   cmd = malloc(sizeof(*cmd));
9006   memset(cmd, 0, sizeof(*cmd));
9007   cmd->type = LIST;
9008   cmd->left = left;
9009   cmd->right = right;
9010   return (struct cmd*)cmd;
9011 }
9012 
9013 struct cmd*
9014 backcmd(struct cmd *subcmd)
9015 {
9016   struct backcmd *cmd;
9017 
9018   cmd = malloc(sizeof(*cmd));
9019   memset(cmd, 0, sizeof(*cmd));
9020   cmd->type = BACK;
9021   cmd->cmd = subcmd;
9022   return (struct cmd*)cmd;
9023 }
9024 
9025 
9026 
9027 
9028 
9029 
9030 
9031 
9032 
9033 
9034 
9035 
9036 
9037 
9038 
9039 
9040 
9041 
9042 
9043 
9044 
9045 
9046 
9047 
9048 
9049 
9050 
9051 
9052 char whitespace[] = " \t\r\n\v";
9053 char symbols[] = "<|>&;()";
9054 
9055 int
9056 gettoken(char **ps, char *es, char **q, char **eq)
9057 {
9058   char *s;
9059   int ret;
9060 
9061   s = *ps;
9062   while(s < es && strchr(whitespace, *s))
9063     s++;
9064   if(q)
9065     *q = s;
9066   ret = *s;
9067   switch(*s){
9068   case 0:
9069     break;
9070   case '|':
9071   case '(':
9072   case ')':
9073   case ';':
9074   case '&':
9075   case '<':
9076     s++;
9077     break;
9078   case '>':
9079     s++;
9080     if(*s == '>'){
9081       ret = '+';
9082       s++;
9083     }
9084     break;
9085   default:
9086     ret = 'a';
9087     while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
9088       s++;
9089     break;
9090   }
9091   if(eq)
9092     *eq = s;
9093 
9094   while(s < es && strchr(whitespace, *s))
9095     s++;
9096   *ps = s;
9097   return ret;
9098 }
9099 
9100 int
9101 peek(char **ps, char *es, char *toks)
9102 {
9103   char *s;
9104 
9105   s = *ps;
9106   while(s < es && strchr(whitespace, *s))
9107     s++;
9108   *ps = s;
9109   return *s && strchr(toks, *s);
9110 }
9111 
9112 struct cmd *parseline(char**, char*);
9113 struct cmd *parsepipe(char**, char*);
9114 struct cmd *parseexec(char**, char*);
9115 struct cmd *nulterminate(struct cmd*);
9116 
9117 struct cmd*
9118 parsecmd(char *s)
9119 {
9120   char *es;
9121   struct cmd *cmd;
9122 
9123   es = s + strlen(s);
9124   cmd = parseline(&s, es);
9125   peek(&s, es, "");
9126   if(s != es){
9127     printf(2, "leftovers: %s\n", s);
9128     panic("syntax");
9129   }
9130   nulterminate(cmd);
9131   return cmd;
9132 }
9133 
9134 struct cmd*
9135 parseline(char **ps, char *es)
9136 {
9137   struct cmd *cmd;
9138 
9139   cmd = parsepipe(ps, es);
9140   while(peek(ps, es, "&")){
9141     gettoken(ps, es, 0, 0);
9142     cmd = backcmd(cmd);
9143   }
9144   if(peek(ps, es, ";")){
9145     gettoken(ps, es, 0, 0);
9146     cmd = listcmd(cmd, parseline(ps, es));
9147   }
9148   return cmd;
9149 }
9150 struct cmd*
9151 parsepipe(char **ps, char *es)
9152 {
9153   struct cmd *cmd;
9154 
9155   cmd = parseexec(ps, es);
9156   if(peek(ps, es, "|")){
9157     gettoken(ps, es, 0, 0);
9158     cmd = pipecmd(cmd, parsepipe(ps, es));
9159   }
9160   return cmd;
9161 }
9162 
9163 struct cmd*
9164 parseredirs(struct cmd *cmd, char **ps, char *es)
9165 {
9166   int tok;
9167   char *q, *eq;
9168 
9169   while(peek(ps, es, "<>")){
9170     tok = gettoken(ps, es, 0, 0);
9171     if(gettoken(ps, es, &q, &eq) != 'a')
9172       panic("missing file for redirection");
9173     switch(tok){
9174     case '<':
9175       cmd = redircmd(cmd, q, eq, O_RDONLY, 0);
9176       break;
9177     case '>':
9178       cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
9179       break;
9180     case '+':  
9181       cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
9182       break;
9183     }
9184   }
9185   return cmd;
9186 }
9187 
9188 
9189 
9190 
9191 
9192 
9193 
9194 
9195 
9196 
9197 
9198 
9199 
9200 struct cmd*
9201 parseblock(char **ps, char *es)
9202 {
9203   struct cmd *cmd;
9204 
9205   if(!peek(ps, es, "("))
9206     panic("parseblock");
9207   gettoken(ps, es, 0, 0);
9208   cmd = parseline(ps, es);
9209   if(!peek(ps, es, ")"))
9210     panic("syntax - missing )");
9211   gettoken(ps, es, 0, 0);
9212   cmd = parseredirs(cmd, ps, es);
9213   return cmd;
9214 }
9215 
9216 struct cmd*
9217 parseexec(char **ps, char *es)
9218 {
9219   char *q, *eq;
9220   int tok, argc;
9221   struct execcmd *cmd;
9222   struct cmd *ret;
9223 
9224   if(peek(ps, es, "("))
9225     return parseblock(ps, es);
9226 
9227   ret = execcmd();
9228   cmd = (struct execcmd*)ret;
9229 
9230   argc = 0;
9231   ret = parseredirs(ret, ps, es);
9232   while(!peek(ps, es, "|)&;")){
9233     if((tok=gettoken(ps, es, &q, &eq)) == 0)
9234       break;
9235     if(tok != 'a')
9236       panic("syntax");
9237     cmd->argv[argc] = q;
9238     cmd->eargv[argc] = eq;
9239     argc++;
9240     if(argc >= MAXARGS)
9241       panic("too many args");
9242     ret = parseredirs(ret, ps, es);
9243   }
9244   cmd->argv[argc] = 0;
9245   cmd->eargv[argc] = 0;
9246   return ret;
9247 }
9248 
9249 
9250 
9251 struct cmd*
9252 nulterminate(struct cmd *cmd)
9253 {
9254   int i;
9255   struct backcmd *bcmd;
9256   struct execcmd *ecmd;
9257   struct listcmd *lcmd;
9258   struct pipecmd *pcmd;
9259   struct redircmd *rcmd;
9260 
9261   if(cmd == 0)
9262     return 0;
9263 
9264   switch(cmd->type){
9265   case EXEC:
9266     ecmd = (struct execcmd*)cmd;
9267     for(i=0; ecmd->argv[i]; i++)
9268       *ecmd->eargv[i] = 0;
9269     break;
9270 
9271   case REDIR:
9272     rcmd = (struct redircmd*)cmd;
9273     nulterminate(rcmd->cmd);
9274     *rcmd->efile = 0;
9275     break;
9276 
9277   case PIPE:
9278     pcmd = (struct pipecmd*)cmd;
9279     nulterminate(pcmd->left);
9280     nulterminate(pcmd->right);
9281     break;
9282 
9283   case LIST:
9284     lcmd = (struct listcmd*)cmd;
9285     nulterminate(lcmd->left);
9286     nulterminate(lcmd->right);
9287     break;
9288 
9289   case BACK:
9290     bcmd = (struct backcmd*)cmd;
9291     nulterminate(bcmd->cmd);
9292     break;
9293   }
9294   return cmd;
9295 }
9296 
9297 
9298 
9299 
9300 
9301 
9302 
9303 
9304 
9305 
9306 
9307 
9308 
9309 .code16                       
9310 .globl start
9311 start:
9312   cli                         
9313 
9314   
9315   xorw    %ax,%ax             
9316   movw    %ax,%ds             
9317   movw    %ax,%es             
9318   movw    %ax,%ss             
9319 
9320   
9321   
9322 seta20.1:
9323   inb     $0x64,%al               
9324   testb   $0x2,%al
9325   jnz     seta20.1
9326 
9327   movb    $0xd1,%al               
9328   outb    %al,$0x64
9329 
9330 seta20.2:
9331   inb     $0x64,%al               
9332   testb   $0x2,%al
9333   jnz     seta20.2
9334 
9335   movb    $0xdf,%al               
9336   outb    %al,$0x60
9337 
9338   
9339   
9340   
9341   lgdt    gdtdesc
9342   movl    %cr0, %eax
9343   orl     $CR0_PE, %eax
9344   movl    %eax, %cr0
9345 
9346 
9347 
9348 
9349 
9350   
9351   
9352   
9353   ljmp    $(SEG_KCODE<<3), $start32
9354 
9355 .code32  
9356 start32:
9357   
9358   movw    $(SEG_KDATA<<3), %ax    
9359   movw    %ax, %ds                
9360   movw    %ax, %es                
9361   movw    %ax, %ss                
9362   movw    $0, %ax                 
9363   movw    %ax, %fs                
9364   movw    %ax, %gs                
9365 
9366   
9367   movl    $start, %esp
9368   call    bootmain
9369 
9370   
9371   
9372   movw    $0x8a00, %ax            
9373   movw    %ax, %dx
9374   outw    %ax, %dx
9375   movw    $0x8ae0, %ax            
9376   outw    %ax, %dx
9377 spin:
9378   jmp     spin
9379 
9380 
9381 .p2align 2                                
9382 gdt:
9383   SEG_NULLASM                             
9384   SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)   
9385   SEG_ASM(STA_W, 0x0, 0xffffffff)         
9386 
9387 gdtdesc:
9388   .word   (gdtdesc - gdt - 1)             
9389   .long   gdt                             
9390 
9391 
9392 
9393 
9394 
9395 
9396 
9397 
9398 
9399 
9400 
9401 
9402 
9403 
9404 
9405 
9406 
9407 #include "types.h"
9408 #include "elf.h"
9409 #include "x86.h"
9410 #include "memlayout.h"
9411 
9412 #define SECTSIZE  512
9413 
9414 void readseg(uchar*, uint, uint);
9415 
9416 void
9417 bootmain(void)
9418 {
9419   struct elfhdr *elf;
9420   struct proghdr *ph, *eph;
9421   void (*entry)(void);
9422   uchar* pa;
9423 
9424   elf = (struct elfhdr*)0x10000;  
9425 
9426   
9427   readseg((uchar*)elf, 4096, 0);
9428 
9429   
9430   if(elf->magic != ELF_MAGIC)
9431     return;  
9432 
9433   
9434   ph = (struct proghdr*)((uchar*)elf + elf->phoff);
9435   eph = ph + elf->phnum;
9436   for(; ph < eph; ph++){
9437     pa = (uchar*)ph->paddr;
9438     readseg(pa, ph->filesz, ph->off);
9439     if(ph->memsz > ph->filesz)
9440       stosb(pa + ph->filesz, 0, ph->memsz - ph->filesz);
9441   }
9442 
9443   
9444   
9445   entry = (void(*)(void))(elf->entry);
9446   entry();
9447 }
9448 
9449 
9450 void
9451 waitdisk(void)
9452 {
9453   
9454   while((inb(0x1F7) & 0xC0) != 0x40)
9455     ;
9456 }
9457 
9458 
9459 void
9460 readsect(void *dst, uint offset)
9461 {
9462   
9463   waitdisk();
9464   outb(0x1F2, 1);   
9465   outb(0x1F3, offset);
9466   outb(0x1F4, offset >> 8);
9467   outb(0x1F5, offset >> 16);
9468   outb(0x1F6, (offset >> 24) | 0xE0);
9469   outb(0x1F7, 0x20);  
9470 
9471   
9472   waitdisk();
9473   insl(0x1F0, dst, SECTSIZE/4);
9474 }
9475 
9476 
9477 
9478 void
9479 readseg(uchar* pa, uint count, uint offset)
9480 {
9481   uchar* epa;
9482 
9483   epa = pa + count;
9484 
9485   
9486   pa -= offset % SECTSIZE;
9487 
9488   
9489   offset = (offset / SECTSIZE) + 1;
9490 
9491   
9492   
9493   
9494   for(; pa < epa; pa += SECTSIZE, offset++)
9495     readsect(pa, offset);
9496 }
9497 
9498 
9499 
